Maximo Application Framework (MAF aka Graphite) Development Information June 2022 Overview	7 Declarative UI	8 Elements	8 Properties	9 Element IDs	9 Bindings	10 Complex Expressions	11 Layout	12 Box	12 Border Layout	12 Templates	13 Page Layout	13 Templates	15 Overview	15 A sample template	15 Template parameters	16 Template slots	16 Best practices	17 Summary	18 Pages and Navigation	19 Passing information between pages	19 State	21 Application and Page State	21 State and Navigation	22 List of Application State Variables	22 Controllers and Events	24 Events	24 Named events	24 Events as expressions	25 Lifecycle Events	26 Application Lifecycle Methods	27 Page Lifecycle Methods	27 Application, Page, Data loading Lifecycle	29 Datasources	30 Using Datasources	30 Data Formatting	32 Common Types	32 Uncommon Types	32 Using types in JSON Schema	33 Dialogs	34 Dialogs and Drawers	34 Dialog	34 Flyout	34 Lookup	35 Drawer	35 Opening Dialogs	36 Common Dialogs	36 Dialog Controllers and Lifecycle Events	37 Checking for Changes on a Sliding Drawer	37 Charts	38 Pie Charts	38 Bar Charts	39 Line Charts	39 Line Linear Charts	40 Donut Charts	40 Events and arguments	41 Localization	42 Creating and Bundling Localization Files	42 Adding Custom Messages for Localization	42 Generating Mock Localization Files	43 Managing Data on a Page	44 Datasource.state.canSave	44 Unsaved Changes Dialog	44 Using a Custom Save Transition	45 Marking items as required	45 Application lifecycle diagram	46 Development Best Practices	48 A guide of best practices for Graphite development	48 Avoid custom components	48 Use smart-input instead of discrete components like text-input	48 Create components that use a Datasource	48 Do not store class instances in the state	48 When defining and using attributes use lowercase for maximo datasources	48 Never use app.datasources or page.datasources	49 Never use the same event name in multiple controllers unless you want that event handled in EACH controller	49 Application Storage and Deployment	50 UpdateDB	50 Maxdev-cli Upload-app	50 MAFAPPDATA Insert Rules	51 Application Deployment	52 Invoking an Application	52 Application Data Cleanup Cron Task	53 Datasource Overview	54 State	55 Loading Data	56 Loading Static Data	56 Loading Dynamic Data	56 Query	57 Response	57 Handling Changes	58 Reset Datasource State	59 USE CASE #1 (Dialog stays open, Lookup is Re-Opened)	59 USE CASE #2 (Lookup is closed, Dialog is Re-Opened)	59


Controllers	61 onDatasourceInitialized(Datasource)	61 onBeforeLoadData(Datasource, Query)	61 onAfterLoadData(Datasource, Item[], Query)	61 onLoadDataFailed(Error, Datasource, Query)	61 onBeforeSaveData({datasource, items, throwError})	61 onAfterSaveData({datasource, items, hasNewItems})	61 onSaveDataFailed({datasource, items, warnings})	61 onBeforeAddData({datasource, item, options})	62 onAddDataFailed({datasource, item, error})	62 onBeforeAddNewData({datasource, options})	62 onAddNewRecord({datasource, item})	62 onAddNewFailed({error, datasource, response})	62 onValueChanged({datasource, item, field, oldValue, newValue, changes})	62 Depending on other Datasources	63 Schema	64 Defining Schema in the Declarative UI	64 Schema Attribute Properties	65 Computed and non persistent attributes	66 Common Datasource APIs	67 Common Datasource APIs for use with JavaScript Controllers	67 Finding a Datasource	67 Force loading a datasource	67 Searching a datasource	67 Search using QBE	67 Iterating over data	67 Item selection	68 Get an item	68 Saving changes	68 Undo changes	68 QBE Filtering	69 Overview	69 Example of a QBE section.	69 Example of a QBE section within a datasource.	69 QBE Field Attribute Properties	70 Example:	70 QBE Range Queries	71 Example #1: QBE section within a datasource that includes QBE range filtering with (age) INTEGER	71 Example #2: QBE section within a datasource that includes QBE range filtering with (birthdate) DATE	72


Timeline Queries	74 Overview	74 Using timeline queries	74 Integration into the UI	74 Customizing and adding your own timelines	75 Timeline Query Format	75 Javascript Overview	77 Overview	77 Async and Await	78 Using async pageResumed lifecycle method	78 Show a page loading while waiting for data	79 async with try / catch / finally	80 Resolve promises in unit tests	80 Async functions that await on return	82 Mobile Supported Flag	84 Overview	84 How to flag a component as not supported in mobile (component UI developer)	85 How to flag a specific property of a component as not supported in mobile (component UI developer)	85 Dates and Times	86 Overview	86 How Maximo handles Dates and Times	86 The REST APIs and Maximo Date and Times	87 What happens if you mix and match timezones	87 TIME: Scenarion 1 - We send timezone information	88 TIME: Scenarion 2 - We send timezone information on send but strip it when viewed	88 TIME: Scenarion 3 - Timezone is ignored	88 Graphite and timezones	89 Drilldown n-levels using Hierarchical Datasources	90 Setting Up an n-level Drilldown Datasource	90 Maximo-Datasource Properties	90 Schema Attribute Properties Used When Defining n-level Hierarchy Datasources	90 Datasource Schema Attributes Explained Further	90 Datasource Setup #1:	91 Datasource Setup #2:	91 Datasource Setup #3:	91 Datasource Setup #4:	91 Datalist Setup:	92 Child-Data Filtering	93 Maximo-Child-Filter - Properties	93 A related child set can be sorted, filtered, and/or limited by using the following properties.	93 Restriction	94 Localization	95 Determining your Language and Locale	95

This document provides information about the Maximo Application Framework (MAF, aka Graphite).  The content in this document was sourced from IBM documentation for Maximo development teams.  Selected information may be specific to IBM developers and may not be applicable to Maximo implementers.  Any references to building applications using commands should be ignored as implementers should download/build/publish an application using the MAF Configuration Application. Declarative UI Graphite Applications consist of one or more XML files that represent the UI and some JavaScript files used for validation, data manipulation, etc. Every Graphite application follows the following XML structure. Root Element - usually application or maximo-application Application State variables - State that is shared across pages Application Datasources - Datasources that are shared across pages Application Dialogs Pages Element Page Element Page State variables Page Datasources - Datasources that are only used in this page Page components Page Dialogs


All elements use lowercase and snake-case element names and attributes. eg., <border-layout hidden="true"> <top background-color="support-01" horizontal-overflow="visible" vertical-overflow="visible"> <label label="Top"/> </top> </border-layout> Elements and attributes are validated at build time when you run `yarn build`. If you use an invalid element or attribute or attribute value the console will provide an error or warning and show a list of valid options. Getting Element Help From the command line you can get a list of valid elements using yarn man --list `yarn man` is just a short form for `npx @maximo/maxdev-cli man` To get help for any element you can run yarn man ELEMENT_NAME ie, yarn man button. Help for the tab might look like this… $ npx @maximo/maxdev-cli man tab

PROPERTIES
All elements have a set of defined properties of a given type or enumeration. Again, if you specify an incorrect property on an element, it will generate an error at build time. The man command gives information about properties, their type, and whether or not they are required. Element IDs Graphite elements support an id property. In most cases, you do not need to supply the id unless the id is marked as required. If the id is not required, an ID is automatically generated for the element during the build and the XML file is updated with the generated id. Generated IDs are typically 5 characters in length and have a random mix of letters and number.

IDS ARE USED IN GRAPHITE APPLICATIONS FOR THE FOLLOWING REASONS:
IDs are used during the add-on and upgrade cycles so that you can determine what has changed in an application, or, how and where you need to apply customizations. IDs are used in automation testing to identify parts of the UI for testing tools. IDs are used to reference other parts of the XML document from within XML or JavaScript code. For example, a datasource will require an id, such as <maximo-datasource id="myds"/>, so that you can directly reference that datasource, such as <field value={myds.state.count}/>. IDs can also be used in the automatic generation of ReactJS files. For example, <page id='MyPage'> might generate a file like PageMyPage.js. You can change the IDs that are in the application XML, even if they are generated, until you decide to deliver your changes. After you deliver your changes, avoid changing IDs because changing IDs can affect automation tests. Never change IDs after applications are delivered to a customer because customers may have customization that depend on those IDs. Although most IDs are automatically generated, you should evaluate IDs in your XML file before you deliver your change to make sure they are human-readable.

Slots is another important aspect to understand about Graphite components. If a component defines slots, then that component is acting as a template where there are named areas of that template that can accept children. For example, the following fictitious component called <custom-page> defines a slot for header, content, and footer so that the <custom-page> components can have template areas with names, header, content, footer. You can then add child components to the <custom-page> and simply tell the component where these children should go. NOTE: <custom-page> is not a real graphite element. It is used here simply to illustrate the concept of slots. <custom-page> <label slot="header" label="My Header"/> <container slot="content"> <label label="My Page Content" /> </container> <container slot="footer"> <label label="Copyright 2019"/> In cases where components accept slots, this is done to allow that component to accept a variety of different elements into those named areas. Slots are not used often, but they are used and you should be aware of their usages.

A POWERFUL ASPECT OF GRAPHITE APPLICATIONS IS THE BINDING FRAMEWORK. A BINDING IS CODE THAT IS ATTACHED TO AN ATTRIBUTE OF THE XML ELEMENT. BINDINGS PROVIDE A RICH SET OF FEATURES, INCLUDING:

Data Formatting Data Validation Data Updating Conditional Expressions You can easily spot bindings in an XML document, since they look like the following, attribute="{custom code}", where you have an attribute with a quoted text but that text uses {} to encapsulate some expression. While the code within the braces does appear to be JavaScript code, don’t expect it to be JavaScript code, but rather a part of the DSL for the XML file. What you put between those braces will get parsed and validated, and we can prevent some JavaScript code in the process. Two-way data binding In the app.xml components that are input components, such as text input components and toggles, automatically perform two-way data binding operations. What this means is that when you bind some state to the form input control, the control will get that value, and if that value changes the UI will be updated, and if the user enter a new value then the state for the item is also updated. <text-input value={page.state.name} /> In this example, the initial value of the text-input control will be set to the value of page.state.name. If the user changes the value, then the value of page.state.name is updated to reflect what the user typed in the text-input component. Complex Expressions Bindings can support complex expression, specifically the ternary operator of JavaScript. This can be used to build conditional UI logic into your application. <button label="Create Work Order" hidden="{page.state.canCreateWO || page.state.isAdmin}"/> <button label="{page.state.currentItem ? page.state.editLabel, page.state.createLabel}"/> Binding keywords In graphite there are number of binding keywords or reserved words that are globally scoped. page - Always refers to the current Page object which holds state and other information about the page. app - Always refers the global Application object which holds state about the application as a whole. datasource - In UI components that accept a datasource and will repeat over items, datasource will always refer to the currently scoped datasource. item - In UI components that accept a datasource and will repeat over items, item will always refer to the current item being rendered. eventManager - Will always point to the object (Datasource, Page, Application) is closest to handle a given event. Graphite bindings implement automatic null safe checking when used as data bindings. ie, {item.serviceRegion.address.city} will not cause an error if any of the object chain is null or undefined.

LAYOUT
Graphite provides a number of contractual layouts and templates. For most day to day use, the <box> and <border-layout> the most commonly used, and they provide a layout contract. Graphite may also provide a container but that should be deprecated in favor of box and border-layout, but you may see some examples and documents reference container still.

BOX
box is similar to a div with specific properties to control alignment, color, etc. It is less flexible than a div and that is by design. All graphite components know how to manage padding and margins, and as such, we don’t want developers spending too much time doing those operations. Things should just align with proper paddings. A box is fundamentally used to arrange content either in a row (horizontally) or column (vertically). It is a simple layout that provides some alignment options: directionality, and color. Boxes can also provide widths as percentages to their children. You can specify something like, children-sizes=“20,60,20”, and it will create 3 sections and space them 20, 60%, 20% and then put the children in those sections. The children-sizes property can be used to simulate a grid, since, you can specify all the sizes and the children will fall into those sized sections. <box children-sizes="50,50" direction="row" > <box background-color="support-03" > <label label="Row 3 Col 1" /> </box> <box background-color="support-03" > <label label="Row 3 Col 2" /> </box> </box> Border Layout A border-layout provides a rigid layout contract offering 5 distinct areas in which content can be placed. top - Content placed here appears above the 3 middle sections, start, middle, end, and fills horizontally that entire space. start - Content here is below the top and to the left of the middle. start will only try to fill as much space as it needs. middle - Content here is below the top and in between the start and end. Middle will always grow to fill any remaining space. end - Content here is below the top and to the right of the middle. end will only try to fill as much space as it needs. bottom - Content here is below the 3 middle sections and fills horizontally that entire space. A border-layout is a very feature rich layout contract with predictable layout behaviors. All sections are optional, meaning that you can composite layouts like, top, middle and bottom, or, start and end, or, middle and end, etc. Multiple border-layout components can be nested. So, you might use a border-layout and then in the middle section also use a border-layout to further layout the content in a given section. Each section of a border-layout supports some alignment, sizing, and color properties. The middle 3 sections start, middle, end also support a width property that can size each of these 3 sections using percentages of the parent container. ie, you might want the start to have a width of 25, meaning that it will always consume 25% of the space. Normally you might not need to provide widths, but, in the cases where you know sections need to have a fixed % width, you can provide it. <border-layout> <top background-color="support-01"> <border-layout fill-parent="true"> <start background-color="interactive-03"> <label label="Top Left 1"/> <label label="Top Left 2"/> </start> <end background-color="ui-03"> <label label="Top Right 1"/>

TEMPLATES
Graphite provides a number of template type components to offer consistency across layouts. These include things like page-layout, header-template, card templates, etc. Page Layout page-layout is a template that can also accept a page-header and page-footer and have them docked in the view. i.e., a footer can be added that is always docked to the bottom of the viewable area. <page-layout id="r8kv8"> <page-footer docked="true" id="w6kgb"> <button label="Footer Button" on-click="{console.log('Button pressed!')}" id="zwqjg"> <tooltip id="n_nq7"> <label slot="content" wrap="true" label="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua." id="e42kw"/> <link slot="link" url="www.ibm.com" label="Learn more" id="pyw9b"/> <button slot="button" label="Click here" on-click="clickMe" id="qkgym"/> </tooltip> </button> While you can create some very complex layouts using border-layout and box, it is a good idea to visit the templates that exist before trying to create your own.


OVERVIEW
Templates provide a way to create reusable XML fragments in your app.xml. For example, you might decide to create a layout template for a card then then use that card template in many places in your XML. Templates support passing parameters and slots, just like regular components. When templates are created, they behave like any other XML element. Templates must be defined at the application level, using the <templates> element with a child <template> element. A sample template The following template creates a 4-column pivot row. This is a row where the label is on the row and the columns represent dynamic data. The logic of the template is that you can specify up to 4 columns to display. The template code is as follows <templates id="wyezx"> <template name="refapp-pivot-template" id="z_v5d"> <template-content id="yq_b6"> <box fill-parent="true" background-color="ui-01" direction="column" children-hide-overflow="true" id="pw82w"> <template-slot name="children" id="y7jm7"/> </box> </template-content> </template> <template name="refapp-pivot-row-template" id="wwdjg"> When using this template you can reference it as such <refapp-pivot-template id="j6pb9"> <refapp-pivot-row-template label="Row 1 using templates with a very long label that should truncate" cols="{page.state.templateCols}" id="k8g7k"> <label slot="labelInfo" label="Label extra info line 1" id="xjpba"/> <label slot="labelInfo" label="Label extra info line 2" padding="bottom" id="nnnmz"/> <label slot="col1" label="Sometext r1 c1" id="kxdp7"/> <label slot="col2" label="Sometext r1 c2" id="m9anb"/> <label slot="col3" label="Sometext r1 c3" id="gn3m5"/> <label slot="col4" label="Sometext r1 c4" id="q_8np"/> </refapp-pivot-row-template> When rendered the above template would look like this… Template parameters Templates support parameters so that when you use them you can pass in parameters to make the template dynamic. Like normal components you can pass numbers, bound state variables, etc. <template name="refapp-pivot-row-template" id="wwdjg"> <template-param name="cols" type="number" required="true" id="bj95b"/> <template-param name="label" type="string" required="true" id="verkv"/> </template> In the above snippet the refapp-pivot-row-template has parameters cols and a label. When you use the template you can pass those parameters. <refapp-pivot-row-template label="Row 2 using templates" cols="{page.state.templateCols}" /> When you declare parameters in a template, you can reference them in the template-content section. You use {template.PARAM_NAME}. The example below uses the template.cols parameters to control the wide of the column and to hide it if cols is set to less than 2. <box size="{100/template.cols}" padding-top=".5" padding-bottom=".5" fill-parent="true" children-hide-overflow="true" hidden="{template.cols<2}"> </box> Template slots Parameters are good for passing in numbers and text, but sometimes you need to pass in complete child content elements. Just how normal Graphite components can accept slots, templates also accept slots. To make a template become aware of slots, you declare a named template-slot in your template. <box size="{100/template.cols}" padding-top=".5" padding-bottom=".5" fill-parent="true" children-hide-overflow="true" hidden="{template.cols<1}" id="wzbv9"> <template-slot name="col1" id="bb745"/> </box> In the above example the template is declaring a slot named col1. When you use the template and specify that slot name the content will get rendered in that location of the template. <refapp-pivot-row-template label="Row 1 using templates with a very long label that should truncate" cols="{page.state.templateCols}" id="k8g7k"> <label slot="col1" label="Sometext r1 c1" id="kxdp7"/> In the above example the <label/> is using the slot col1, meaning that this content should be rendered in the col1 template-slot area. Templates have a special named slot, children, to identify where to render children elements that are passed to the template. <template name="refapp-pivot-template" id="z_v5d"> <template-content id="yq_b6"> <box fill-parent="true" background-color="ui-01" direction="column" children-hide-overflow="true" id="pw82w"> <template-slot name="children" id="y7jm7"/> </box> </template-content> </template> When you use the template, refapp-pivot-template, and you pass it any child elements, they are rendered in the children template-slot. <refapp-pivot-template> <label label="text 1"/> <label label="text 2"/> </refapp-pivot-template> Because the refapp-pivot-template define a children slot, the labels as used above would render in the box of that template. Using the combination of slots and parameters you can make templates very dynamic. Best practices Don’t access datasources directly Don’t do something like this where the template is accessing the dswo datasource directly. In fact this may even fail at run time. <template name="refapp-table-template" id="z_v5d"> <template-content id="yq_b6"> <table datasource="dswo"> </table> </template-content> </template> Instead decare a datasource parameter and pass in the datasource as a parameter. <template name="refapp-table-template" id="z_v5d"> <template-param name="datasource" type="string" required="true"/> <template-content id="yq_b6"> <table datasource="{template.datasource}"> </table> </template-content> </template> And then call call it using the datasource… <refapp-table-template datasource="dswo"/> Don’t access state directly In the same manner as datasources, don’t access page or application state from the template, instead create a template-parameter and pass the state to the template using that parameter. Create very unique template names Since templates create elements, you want to make sure that you create templates that will not clash with existing components or future components. Don’t use template names like chart or map but instead use a combination of your application id and end with template. So create refapp-chart-template. This will make it easy to identify templates and avoid future clashed with elements.


SUMMARY
A well defined template should have no dependencies on your application. You might even share your templates with other teams and they can simply copy and paste your template into their application and use it without modifications. Pages and Navigation Graphite applications consist of multiple page elements that can be routed, or navigated to. A most simple application might look like this… <application id="app" product-name="Sample" title="App"> <menu slot="navigation-items" id="p5jjk"> <menu-item label="About" icon="carbon:home" page="about" /> <menu-item label="Controller Demo" icon="carbon:forum" page="controllerDemo" /> <menu-item label="Containers" icon="carbon:grid" page="containers" /> </menu> <pages id="main"> <page id="about"> <box> The navigation-items slot defines the left side navigational items for your application. You’ll notice that these menu-item elements use page property that references the page to which that menu-item to route to when activated. Elements that support an on-click event, such as menu-item, button, etc. also support some shortcut properties like page to identify that the UI element routes to a given page. Changing pages can also be done programmatically, but, this allows for the UI to easily indicate that the sole purpose of but a clickable element is to route to a page. Not all `page` elements need to have an entry in the navigation items. You only need to put a entry in the navigational items if you want it to show up in the application side navigation. All pages can be directly routed in the browser url using `#/PAGEID`. eg, `#/containers` would automatically route to the `page id="containers"` page. Passing information between pages You can pass page parameters between pages. If you have button that needs to navigate to a details page with an item id, you might do something like this. <button label="Details" on-click="change-page" on-click-arg='{{"name": "details", "params": {"ids": item.wonum}}}' /> change-page is a system event handler that knows how to change pages. The on-click-arg is passing the page name and a param object. The information in the params object is passed on the URL to the receiving page, and, can be accesses using page.params.ids in this case. Graphite intentionally does not deal directly with URLs at the application level, since Graphite applications can be run in a browser and potentially devices that are not a browser. For that reason there are APIs and contracts around page navigation, etc, but the application developer does not deal with URLs directly. If you logic for what you need to pass to the next page that is somewhat complex and cannot be easily expressed in the XML, you can use a custom event and do the work in your controller. That might look something like the following example. <button label="Details" on-click="showDetails" on-click-arg="{datasource}" /> And in your controller you might do something like this…​ showDetails(datasource) { let selectedItems = datasource.getSelectedItems(); let selectedIds = JSON.stringify(selectedItems.map(e => datasource.getId(e))); datasource.clearSelections(); this.app.setCurrentPage({name: 'details', params: {ids: selectedIds}}); }


Application and Page State State is an important concept to understand for Graphite applications. The UI is only updated based on changes to state, either in the application, page, or if some component like a datasource exposes state. Graphite borrows heavily from React’s state management concepts but the inner workings of state is not something that most developers will need to worry about. It is more important to know what state is, and how to use it. In Graphite you cannot access the UI directly so you use state to update the UI. So in Graphite you can do the following Create a state variable to hold the label. Bind the label to the state variable. In the on-click, update the state variable, which automatically updates the UI.


BY USING THE FOLLOWING:
<page> <states> <state name="button_label" value="Hello" type="string" /> </states> <button label="{page.state.button_label}" on-click="{page.state.button_label='World'}"/> </page> From this example, you can see that since the label is bound to a state variable, updating that state variable in any way, also updates the UI. In this example the button has a label of Hello to start, and then when clicked it will change to World. State is managed at the Application and Page scopes. This means is that state that is declared at the application and can be accessed by any page using app.state.YOUR_PROPERTY, where YOUR_PROPERTY is your user defined state variable. When state is declared at the page level, it can only be accessed by that page using page.state.YOUR_PAGE_PROPERTY. There are no other scopes for state. It is just page or application and unless you need to share state across multiple pages, then declare state at the page scope. You can think of state as being global data store for your page and application. State can also be accessed in the controllers, meaning that the JavaScript controller can access the state and modify the state, causing the UI to update. State and Navigation One common use for state is hold the selected tab in a page. You might want to have this information routable meaning as the state changes the URL changes and you can bookmark or navigate to that URL and it would cause that given tab to be selected. For example, you might declare some state as follows… <states> <state name="selectedTabIndex" url-enabled="true" value="0" type="number"/> </states> By using url-enabled when selectedTabIndex changes by any means the URL will be updated. If the URL is updated with a new value then the state is also updated. This is a powerful way to enable the browser back button in your application. List of Application State Variables The global app.state reference includes all the state that you defined in your application. It also has a number of other state properties that can be used directly from the application. State information implies that the UI will react to changes in the state values. This can be used, for example, to hide parts of UI if you are not connected to a network, or, only show some information if your screen is larger than X pixels. <button label="Submit" disabled="{!app.state.networkConnected}" /> <box hidden="{app.state.screen.width < 300}" > <table datasource="ds"/> </box> Changes to screen.width and screen.height are debounced to ensure that the UI does not get overloaded when doing things like resizing, etc. The app can also access non stateful information like the device using app.device and it provide information like if you running on a phone, tablet, or information about the browser. ie, app.device.isMobile will only return true when running on a mobile (ie, phone or tablet). <box hidden="{app.device.isMobile}"> <table datasource="ds" /> </box> Controllers and Events Some components, such as application, page, and datasource support the concept of a Controller or JavaScript class that can perform some basic business logic. In some cases, an element might support a controller attribute that should point to an ES6 JavaScript class. Some components also support multiple controller class="MyClass.js" child controllers. Currently, elements like page,application, andjson-datasource all support multiple controllers. Applications in graphite are event and state based so when multiple controllers are in use, events are dispatched to ALL controllers. You should not expect any predefined behavior in the order in which controllers handle events. That ordering is not determined for controllers defined at the same level. In terms of how events are dispatched, they first handled by a datasource, then the page, and lastly the application. That means you can define all your events in the Application controller for very simple applications. The Events and Lifecycles will get into more specifics around how controllers can be used within the Application event and lifecycles. As a general rule of thumb, controllers should be used to do quick validations of data, or quick post processing of data. You should not be doing long operations in the Controller classes.

Many components support events. For example, a button supports an on-click event. The preferred way to handle an event is by using event names, but events can also be bound expressions. Named events Using a named event means that when the action event fires, the event is pushed on to the event bus where controllers have the first chance to handle that event. Another aspect of named events is that they can support being passed an arg property so that the receiver of the event can get additional information other than just the event name. The following example fires an event named openItem passing as the event data the result of the {item} bound expression. If this were on a repeated item on a card, then the event would get the current item when the button is clicked. <button label="Open" on-click="openItem" on-click-arg="{item}" /> Events are dispatched so that they are first handled by the current item, then the datasource (if in a databound component like a table), then by the page, and then by the application. For the openItem event, the currently active datasource first checks whether its controllers (if any) will handle it. It then checks the page controllers, then the page, then application controllers and then application. Even if the event is handled along the way, it continues to allow all other controllers an opportunity to respond to the event. Controllers can handle events by creating a method that matches the event name. In the following example, a method on the MyPage.js controller called openItem is called if you fire the openItem event. class MyPage { openItem(item) { if (item.isCancelled) { // do something with cancelled item } else { app.setCurrentPage({ name: 'details', params: { id: item._id } }); } } }


AS NOTED BEFORE, AN EVENT CAN HAVE A SINGLE ARGUMENT AND YOU PASS WHATEVER YOU WANT AS THAT ARGUMENT. IF YOU HAVE A USE CASE WHERE YOU NEED MULTIPLE PIECES OF INFORMATION, YOU CAN PASS THE ARGUMENT AS A JSON OBJECT. FOR EXAMPLE, IF YOU WANT THE DATASOURCE AND THE ITEM YOU APPLY THE FOLLOWING:<button label="Open" on-click="openItem" on-click-arg="{{'datasource': datasource, 'item': item}}" /> Because an expression can be just about anything you want, you can create a JSON object and set fields of that object to be the data that you need. In your event function, you can then access it like the following. You’ll notice that the single argument, event, has properties for item and datasource as you defined in the on-click-arg attribute. class MyPage { openItem(event) { if (event.item.isCancelled) { // so something with cancelled item } else { app.setCurrentPage({ name: 'details', params: { id: event.datasource.getId(event.item) }, }); Events as expressions Almost any attribute can be an expression. on-click can be mapped to a named event, or, you can set an expression. The following example logs clicked to the browser’s console when you click the button. <button on-click="{console.log('clicked')}" /> A use case for this may be to fire an event by using the event manager instead of the named events. <button on-click="{eventManager.emit('doSomething', item.wonum)}" /> This is basically the equivalent of using on-click and on-click-arg. You’ll notice that there isn’t an easy way to call a method on your controller and have a value returned that you can use in an expression. The reason for that is you want to build stateful properties and have the UI bind to those properties and then have your controller update those properties. If you do call a method directly and the method returns different values, the UI does not update in response to method’s return value. However, the UI will update in response to changing some state. So, avoid this <button label="Clicks {page.controllers[0].getCounter()}" on-click="{page.controllers[0].incrementCounters()}" /> Since even though that may work, the label will not update on the button when the counter changes. Instead, do this… <button label="Clicks {page.state.counter}" on-click="incrementCounter" on-click-arg="page" /> And in your controller create a method like incrementCounter(page) { page.state.counter = page.state.counter + 1; } Since the UI is bound to a state property, that event can be handled and update the counter, which causes the UI to re-render. Lifecycle Events Page, Application, and Datasource are key classes of the framework and they are generally wrapped and exposed to the XML via the <page>, <application>, and <json-datasource> (or any datasource) elements. These elements as explained, support a controller and each controller has some pre defined methods that will automatically be called if you declare them. While there are predefined lifecycle events that are exposed as methods to controllers, the Graphite JavaScript framework has 100s of other events that can bound to, such as screen and network change events. Although these are not exposed as lifecycle events, applications can bind to them as needed. You will need to review the JavaScript documentation for a complete list of events that are exposed in each class. Application Lifecycle Methods applicationInitialized(Application) - applicationInitialized will be called with the Application instance when the application is initialized. The typically usage for this method is to the capture the application instance and store it, so that you can later use it in other event callbacks. This method is only ever called once. onContextReceived({context, app}) - onContextReceived will be called when an application is launched with a given context. Launching in context is an advanced operation whereby you are communicating information between 2 applications. The context can be any kind of JSON object. onAppSerialize({app}) -onAppSerialize` is called when the application is being pushed to the background, and it gives an opportunity for the application developer to inject additional information into the application state for serialization. onAppDeserialize({app}) -onAppDeserialize` is called when the application is being restored, and it gives an opportunity for the application developer to restore some state or configure the application after being restored. Page Lifecycle Methods pageInitialized(Page, Application) - pageInitialized will be called when the page initialized. It will be passed the Page and Application instances. This method is only ever called once. It is called once all aspects of a page such as datasources have been initialized. A possible use for this method might be to set up various Page state variables based on some complex conditions, or to simply store the Page and Application instances for later use in other event callbacks. pageResumed(Page, Application) - pageResumed will be called when returning to a page. It will be passed the Page instance. A possible use for this method might be to reset the state of the page when you return to it. pagePaused(Page, Application) - Called when the page leaves scope. ie, when you change pages, pagePaused will be called for your current page before calling pageResumed on the next page. getPageStack(Array<Page>, Page) - Called when the page is resumed/initialized to allow a controller to inject additional information into the Array<Page> stack. This is useful for manipulating the Breadcrumb. onPageSerialize({page}) - Called when the application is leaving to go to another application, giving the page an opportunity to save additional stateful information that can be restored once the application resumes. onPageDeserialize({page}) - Called when the application is resuming from another application. pageResumed is always called even the first time the page is created. So if there work that needs to be done for pageInitialized and pageResumed you can do it in the pageResumed and it will be called every time the page is created or resumed. Application, Page, Data loading Lifecycle When a page is being navigated to, the previous page will fire the pagePaused event, allowing the outgoing page to do any necessary cleanup before the page is exited. The new page, ie, the page being activated will fire the pageInitialized event followed by the pageResumed event. pageInitialized in only ever fired once, while pageResumed is fired every time the page is being entered/resumed. Any page parameters that were passed on the URL are evaluated and set into the page.params map for the new page when the page is initialized. After the pageResumed is fired any dynamic properties on the datasource are then processed and these dynamic properties are evaluated and may result in a change to the base query. For example, if <datasource dependent-id="{page.params.ids}" /> exists, then after pageResumed is processed, then {page.params.ids} is evaluated and the datasource is updated with that new value. Once the pageResumed is processed and dynamic properties on the datasource are processed, any datasources on the page that have a pre-load set to true will be loaded. It is at this point, that the page will begin to render. Most components can gracefully manage the data loading phase, and either show a loading, or, show some undefined state while it waits for data. If this is not appropriate then you can use the datasource.state.loading or datasource.state.hasData flags and conditionally render some alternate “wait” state while data is being loaded. If after the initial render, datasource item accesses are tracked, and if these datasources are not in a state of loading then they are now loaded automatically.




DATASOURCES==>Using Datasources There is an entire section dedicated to Datasources, but this section only aims to show how they are used within the UI. For information on creating custom datasources and loading data see the Datasource document A datasource is a data contract between UI components and data, without actually knows where the data comes from. A Datasource uses a DataAdapter for all loading and saving operations. To the UI the Datasource provides the following contracts Ability to load data asynchronously in pages Will cache data Can sort data Can filter data Can search data across fields Can add new items to item collections Can delete items Can update items, and create an undo stack Can manage warnings against fields in an item Will notify the UI of changes Will track selected items Can asynchronously drill into child data Will provide a total count of known items Will debounce querries to prevent overloading of the DataAdapter Will manage dependencies between datasources Can provide type information for each field Provides no restrictions on the shape of the data, other than it is a json array objects that might include nested array or objects Because of all that a datasource can do, it is a complex object that provides a great deal of power to the UI when working with data. For example a datasource might be shared between a card group and a table. Changes that are made to the datasource via the table will automatically show up in the card group, and vice versa. Some components will use a datasource directly. ie, a table will have a datasource property that can be assigned a datasource, and it will use that datasource to render items, etc. In the following example it is expected that the test-data.js will load data that will have a name and age fields. <json-datasource id="ds" id-attribute="_id" src="test-data.js" controller="DataController" pre-load="false"/> <table datasource="ds" can-filter="false" > <table-column name="name" /> <table-column name="age" /> </table> You can also specify a datasource indirectly on a control, and if the control is datasource aware, it will discover the datasource and use it. For example in the following example, ds.item.age is bound to a smart-input. Graphite will automatically pass the datasource, item, and field to the component, in addition to the value. The component will use the datasource information to automatically decide what kind of form input to render. In this case it will render a numeric input, and the title of the field will be set automatically from the datasource schema information. <smart-input value="{ds.item.age}"/> From the application point of view, we can get a lot of information simply because we are bound to a datasource item. Graphite will track when a datasource is needed to be loaded and load data automatically. But, there may be times when you need to refresh the data, or you might be updating the query from the controller and forcing a load. From controllers you can access datasources and force a load, if needed. loadMyData() { this.page.datasources.myds.search('some text') } If the controller code reloads or changes data in a datasource the UI will automatically pick up those changes. Data Formatting In graphite data formatting is managed by the type as defined in the <schema> for the datasource, or by the type of information used in the <state>. From the application developers point of view, they can declare data like <field value="{item.amount}"/> <field value="{item.createddate}"/> Graphite will automatically format data based on the type and in the user’s locale. In some cases you can coerce information to a specific format. <field> <sub-field value="143.25" type="duration_long" /> </field> Which would render 143 hours 15 minutes Graphite’s data formatters can use the following formats, which are usually defined in the <schema> of the json data. Common Types Uncommon Types Using types in JSON Schema As mentioned, providing a schema for your data can allow the UI to make better choices when using data formatting or smart inputs. <json-datasource id="searchds" src="test-data-4.js" id-attribute="_id" selection-mode="multiple" order-by="name"> <schema> <attribute name="name" searchable="true" type="string" sub-type="ALN"/> <attribute name="age" searchable="true" required="true" title="Age" type="number" sub-type="INTEGER"/> <attribute name="birthdate" searchable="true" type="string" sub-type="DATE"/> <attribute name="address" searchable="true" type="string" sub-type="LONGALN"/> </schema> </json-datasource> If datasource does not provide schema information then the UI will format the data based on the raw type of the data which may not be best results


DIALOGS==>Dialogs and Drawers Dialogs, Lookups, Flyouts and Drawers are all defined in the <dialogs> section of a <page> or <application>. Each of these are dialogs in that they present windows over the existing content, but they serve very specific purposes.A Dialog is used to show modal content over a page. It has a primary-action and a secondary-action which are buttons in predefined locations in the dialog window. <dialog id="dialog_with_ds" title="Datasource Demo" on-close-action="{console.log('Dialog closed via X')}" on-primary-action="{console.log('primary action clicked')}" primary-action-text="Primary Action" on-secondary-action="{console.log('secondary action clicked')}" secondary-action-text="Secondary Action"> <json-datasource id="dialogds" id-attribute="_id" src="test-data.js" controller="DataController" pre-load="false"/> <table datasource="dialogds" can-filter="false" id="wypr7"> <table-column name="name" id="v7y3q"/> <table-column name="age" id="qgj2r"/> </table> </dialog> You can have the primary button be conditionally disabled based on the state of a datasource. I.e., the button will be disabled unless there are valid changes to a datasource to be saved. This is done with the ‘primary-button-disabled’ property in the XML, using the “canSave” piece of a datasource’s state. <dialog id="complex_dialog" title="Editing 5 Assets" primary-button-disabled="{!dsb1.state.canSave}" on-primary-action="{app.toast('Saving...')}" primary-action-text="Save Changes" on-secondary-action="{app.toast('Cancelled')}" secondary-action-text="Cancel"> <!-- dialog content --> </dialog>


FLYOUT==>A Flyout is similar to a dialog, but it contains very little window decorations, and it shows relative to another anchor position, such as a button. <flyout id="flyout_with_ds" modal="false" on-close-action="{app.toast('Flyout Closed')}" align="end"> <json-datasource id="flyoutds" src="test-data-4.js" controller="DataController" pre-load="true"/> <container layout="vertical" children-fill-parent-width="true" id="mb2k2"> <table datasource="flyoutds" id="gxzq8"> <table-column name="name" id="vj7k2"/> <table-column name="age" id="ek4r5"/> </table> </container> <flyout-buttons overflow-label="Flyout actions" id="r_8vv">



LOOKUP==>A Lookup is a specialized dialog that contains a datasource and presents the user with a selection choice. <lookup id="testDSLookup" datasource="lookupds" border="true" on-item-click="{app.toast(`Clicked on `+event.name)}" on-secondary-action="{app.toast(`Clicked Cancel. Lookup Closed.`)}" on-primary-action="{app.toast(`Clicked OK. Lookup Closed.`)}" show-search="true" tight="true" lookup-attributes="{['name', 'address']}" height="400" width="60"> <json-datasource id="lookupds" src="test-data-4.js" id-attribute="_id" selection-mode="none" schema="schema" order-by="name"/> </lookup>

DRAWER==>A drawer is a dialog that anchors to the start/end of page and fills the content from top to bottom. These tend to slide in/out from the direction in which they were opened. <sliding-drawer id="drawer1" align="start" header-text="Start Drawer" content-padding="false" controller="DialogController" on-close-action="{app.toast('Start Drawer Closed')}"> <box direction="column" id="y8jga"> <label wrap="true" label="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua." id="r_edy"/> <dropdown selected-item="{page.state.datasourceDropdownSelection}" datasource="{ddms1}" datasource-value-field="_id" datasource-text-field="name" on-footer-click="{console.log('Footer Clicked', event)}" footer-text="DataSource Footer" id="pbv2g"/> <smart-input id="nameDrawerStart" value="{ddms2.item.name}" placeholder="Enter Name" label="What is your name"/> <checkbox-group label="Checkbox Group" options="{page.state.checkBoxGroupData2}" on-change="handleChecked" on-change-arg="{page.state.checkBoxGroupData2}" large="true" single-select="true" id="vkv2j"/> <button-group> <button on-click="{app.toast('Ok')}" label="Ok Toast" id="vzyp8"/> <button on-click="{app.toast('Cancelled')}" label="Cancel Toast" id="xkzmv"/> Each of dialog, lookup and flyout can have their own child datasources and they can have their own JavaScript controller file. These are scoped to the dialog and initialized only when the dialog is first created. The DialogController can be notified when the dialog is opened, closed, and can have its own controller logic that is specific to the dialog in question. Opening Dialogs Components that can accept an on-click event will also have a shortcut to open dialogs, lookups, etc, using the ID of the dialog. The dialog, flyout, drawer, lookup can be defined at the application or page level. You cannot open a dialog on one page from another page. If you need to access a dialog from more than one page, then it should be defined at the application level. <button dialog="dialog_with_ds" label="Open Dialog"/> <button flyout="flyout_with_ds" label="Open Flyout"/> <button lookup="testDSLookup" label="Open Lookup"/> <button drawer="drawer1" label="Open Drawer"/> From the controller code you can also open dialogs. this.app.showDialog('drawer1'); Common Dialogs From the application controller code, you might need to show an error or ask a question. You do that using a reference to the Application object. Show an error app.error('The record was not saved'); Show Confirmation if (await app.prompt('Are you sure?')) { this.deleteRecord(); } Prompt for Simple Text Input let name = await app.prompt('What is your name?'); Dialog Controllers and Lifecycle Events A dialogs (ie, flyout, drawer, lookup, dialog) can have a controller attribute, or can handle events at the page or application level. The following lifecycle events will be called. dialogInitialized(Dialog) - Called the first time the dialog is created. dialogOpened(Dialog) - Called every time the dialog is opened. dialogClosed(Dialog) - Called every time the dialog is closed. Checking for Changes on a Sliding Drawer A common use-case is to use sliding drawers to capture user input. If the user closes the drawer, it is often desirable to ask them if they want to save their changes. In order to enable this, two things must be set in the XML. First, the page containing the drawer must have the piece of state “useConfirmDialog” set to true. <page id="Test" path="test" controller="PageController"> <states> <state name="useConfirmDialog" value="true" type="boolean" /> </states> <!-- Page content --> </page> Second, the sliding-drawer must be passed the name of the datasource to validate via the prop “validate-on-exit.” <sliding-drawer id="docked_drawer1" align="start" validate-on-exit="{ddms2}" enabled-docked-button="true" dock-on-expand="true" header-text="Start Drawer with docked content" content-padding="false" controller="DialogController" on-close-action="{app.toast('Start Drawer Closed')}"> <!-- Drawer content --> </sliding-drawer> In the example above, when the drawer is closed, it will check if there are any changes made against the datasource “ddms2,” and, if there are, prompt the user to save or discard their changes. For more information on the confirmation dialog, see Managing Data on a Page.

CHARTS==>There are several types of Carbon Charts all accessible by using the Graphite <SmartChart>. Currently donut, pie, line, linear-line and bar charts are supported. The link to Carbon’s simple charts is defined here: https://www.carbondesignsystem.com/data-visualization/simple-charts/


CHARTS CAN HAVE OPTIONS, TOOLBARS, AND LEGENDS. THE OPTIONS DEFINE THINGS LIKE WHAT THE X AND Y AXES MAP TO. AN EXAMPLE IS:
<chart-option name="data.groupMapsTo" value="Year"/> <chart-option name="data.valueMapsTo" value="Net Profit"/> <chart-option name="donut.center.label" value="Net Profit"/> <chart-option name="alignment" value="center"/> <chart-option name="animations" value="cenfalseter"/> <chart-toolbar enabled="true"/> <chart-legend position="top" alignment="end" orientation="horizontal"/> Pie Charts An example of a Pie Chart. <chart type="pie" datasource="{salesds1}" height="400" on-segment-click="{app.toast('You clicked ' + arg)}" on-segment-click-arg="Pie Segment" id="z8raap"> <chart-option name="data.groupMapsTo" value="Year" id="r_aa_d7"/> <chart-option name="data.valueMapsTo" value="Net Profit" id="gxax2j"/> <chart-legend alignment="end" id="am6gek"/> </chart> Bar Charts An example of a Bar Chart. <chart type="bar" datasource="{salesds1}" height="400"> <chart-axis position="bottom" title="Year" data-field="Year"/> <chart-axis position="start" title="Net Profit" data-field="Net Profit" scale-type="linear"/> <chart-option name="data.groupMapsTo" value="Season"/> <chart-toolbar enabled="true"/> <chart-legend position="top" orientation="vertical" alignment="end"/> </chart> Line Charts An example of a Line Chart. <chart type="line" height="400" datasource="{stockds1}"> <chart-option name="data.groupMapsTo" value="Ticker"/> <chart-option name="curve" value="curveMonotoneX"/> <chart-toolbar /> <chart-legend position="top" alignment="end"/> <chart-axis position="bottom" title="Date" data-field="Date" scale-type="time"/> <chart-axis position="start" title="Close" data-field="Close" scale-type="linear"/> </chart> Line Linear Charts An example of a Line Linear Chart. <chart type="line-linear" height="400" datasource="{stockds2}"> <chart-option name="data.groupMapsTo" value="Ticker"/> <chart-option name="curve" value="curveMonotoneX"/> <chart-legend position="top" alignment="end"/> <chart-axis position="bottom" title="Date" data-field="Date" scale-type="labels"/> <chart-axis position="start" title="Close" data-field="Close" scale-type="linear"/> </chart> Donut Charts An example of a Donut Chart. <chart type="donut" datasource="{salesds1}" height="400" on-segment-click="{app.toast('You clicked ' + arg)}" on-segment-click-arg="Donut Segment" id="zaa8rap"> <chart-option name="data.groupMapsTo" value="Year" id="r_paa_d7"/> <chart-option name="data.valueMapsTo" value="Net Profit" id="gxaxss2j"/> <chart-option name="donut.center.label" value="Net Profit" id="sasewak7"/> <chart-option name="alignment" value="center" id="uaua9ga"/> <chart-option name="animations" value="cenfalseter" id="uaua93a"/> <chart-option name="accessibility" value="false" id="s8uaa9ga"/> <chart-toolbar enabled="true" id="naa3w2y3"/> <chart-legend id="aa6gwek" position="top" alignment="end"/> Events and arguments You can define <on-segment-click> and <on-segment-click-args> to perform actions on the segments of a chart.

Graphite applications require minimal effort to support multiple languages. In the xml, text in the localizable attributes is extracted automatically for localization. When the application is built, Graphite automatically adds code that performs the localization updates. In the following example, the button’s label is automatically extracted for localization, and when the button is rendered it automatically injects the localized text. If localization is not available, the text defaults to your static text. <button label="Clicks {page.state.counter}" on-click="incrementCounter" on-click-arg="page" /> Having bound expressions in localizable labels will also be correctly handled. The localized text becomes "Clicks {0}" and later the "{0}" is automatically replaced with {page.state.counter}. To assist with the verification of localization, we have introduced a query parameter that can be added to the url to make all localizable labels prefixed with characters to help the user validate if their app is missing any labels that were not marked for localization. The query param _graphite_mock should be appended to the URL and can be given a value of either de (German) or ja(Japanese). Labels will appear prefixed as seen in the example below: [(')一構ソチ‐ User Name] or [(')~~~~~~~~~~ User Name] Example:: _graphite_mock=ja or _graphite_mock=de Creating and Bundling Localization Files Graphite provides tools to create the base localization files. npx @maximo/maxdev-cli localize -i ./src/app.xml -o ./src/i18n/labels.json --format json This will create the src/i18n/labels.json for all text in the app.xml and components from the component library. This file can be translated into additional languages, and when you get these languages back you can place them into public/i18n/ folder. A language file would be named as such, labels-LANGCODE.json, ie, label-en-gb.json or labels-fr.json Graphite will load the language file based on the locale of the user. Adding Custom Messages for Localization You can use the messages element to add additional translatable elements to your application. The reason to do this might be so that you can use those messages from JavaScript code. <messages> <message id="errorMessage" text="We are unable to save at this time.  Please try again later."/> </messages> Later you can reference that message from JavaScript. app.toast(app.getLocalizedMessage(APPID, 'errorMessage', DEFAULT_VALUE)); All messages defined in the application will get translated as a part of the label.json file. Generating Mock Localization Files You may want to test localization with other kinds of language files and verify that things are getting extracted and injected correctly. You can generate mock files very easily. Mocked text is not valid text. It just has the original English text combined with language characters from other languages. It is simply meant to test if the UI will render those characters, or, if the there are missing elements that need to be translated. npx @maximo/maxdev-cli localize -i ./src/app.xml -o ./build/app/public/i18n/labels-ja.json --format json --mock ja This will create a mock Japanese file. You can also create a mock file using a template. This can be useful to inject non-Latin language characters into the mock text. npx @maximo/maxdev-cli localize -i ./src/app.xml -o ./build/app/public/i18n/labels-en-ca.json --format json --mock '[{text} ~~(eh)]' Managing Data on a Page Datasource.state.canSave On a page, it might be useful to restrict a user’s ability to save or leave the page if the data on that page has been changed. Each datasource keeps track of whether it is currently in a state to be saved, stored in a piece of state called “canSave.” <button label="Save data" disabled="{!ds.state.canSave}" /> In the above example, the button will be disabled until the datasource has determined that it is able to save. On every change to an item, the datasource will validate that change and check whether it can now be saved. If an invalid change is detected, such as a required field not being filled in, or an input of the wrong type, then the button will not allow saving. Something similar can be done with dialogs, using the ‘primary-button-disabled’ prop. <dialog id="myDialog" title="Dialog" primary-button-disabled="{ds.state.canSave}"> <!-- Dialog content --> </dialog> Unsaved Changes Dialog It’s also possible to show a dialog to the user when they attempt to leave the page with unsaved changes. Clicking the “Save” button will save the changes on the page and move to the next page. Clicking the “Discard” button will discard the changes, and move to the next page. Clicking the X in the top-right corner will keep the user on the current page, with their changes intact. This dialog MUST be turned on, on a page-by-page basis. This is done by setting a piece of state on the page called “useConfirmDialog.” <page id="Test" path="test" controller="PageController"> <states> <state name="useConfirmDialog" value="true" type="boolean" /> </states> <!-- Page content --> </page> You can also toggle this functionality programatically, from a controller for example. toggleConfirmDialog(useConfirmDialog) { page.state.useConfirmDialog = useConfirmDialog } Using a Custom Save Transition Sometimes, you might want to do your own validation when the user hits ‘save’ on the above dialog. This is possible to do in the controller of the page in question. Place your own validation function inside the controller with the name “onCustomSaveTransition.” (For more info on controllers, see the “Controllers and Events” page) async onCustomSaveTransition(event) { //Validation happens here return {saveDataSuccessful: true, callDefaultSave: true}; } The function MUST return an object with two values: saveDataSuccessful and callDefaultSave. Set saveDataSuccessful to true if everything in your function went successfully. If you do not, then the app will think saving failed and not transition pages correctly. If you also want the default save function to be called, set callDefaultSave to true. Without this, it is possible that some data might not be saved, so make sure you cover everything in the custom function. Marking items as required Whether a field is required can be determined by the schema, but it is also possible to set it in the MAML. <smart-input label="Edit expected life" required="true" id="kn9bm" value="{dsb1.item.expectedLife}"/> Setting required on an item like this can only turn make something required when it was not in the schema. If an item is marked as required in the schema, it will ALWAYS be required Application lifecycle diagram Development Best Practices A guide of best practices for Graphite development Avoid custom components Graphite supports custom components but they should be used sparingly. If you need a component that doesn’t exist, work with the Graphite team and see if you can add it to the set of common components. Do not subclass our components and add small features. Work with the team to get these features added. Custom components may not work correctly on mobile. Custom components may be confusing when trying to configure them. Use smart-input instead of discrete components like text-input smart-input works with a Datasource automatically wiring up the 2 way data binding smart-input binds automatically to the error state of a field in a datasource smart-input will select the render component based on the type of data smart-input can show field help based the field schema information If your data is coming from a datasource then you should use a smart-input to minimize the dev efforts of managing the validation/error states, etc Create components that use a Datasource If your component is being designed to accept an array of data, then switch to using a datasource instead. Datasources can load large amounts of data efficiently Datasources can sort, search, filter data in a consistent way Datasources have events that your component can hook into to know when data is being loaded Do not store class instances in the state State should be used to store serializable data such as JavaScript primitives, Arrays, and Objects. Storing class instances (ie Objects with functions) may prevent your application from being able to serialize its state When defining and using attributes use lowercase for maximo datasources Define schema attribute names in lowercase When using an attribute, use lowercase. ie, do use item.status and do not use item.STATUS. Maximo will always send us field names in lowercase. Never use app.datasources or page.datasources Other than .state all other properties on a page or application is private in scope. These can change in the future, they are not part of the API. use app.findDatasource(name) if you need to locate a datasource from controller code. This finds the datasource no matter which page it is defined in for the application. in the app.xml never use page.datasources or app.findDatasource, you can simply use the datasource name like {dsWO} since all datasources are in scope of the XML. Never use the same event name in multiple controllers unless you want that event handled in EACH controller If you create an event like loadApp and the Data, Page, and Application controller levels, that event will get handled 3 times. If you declare an event at the Page/Data controller level and it is NOT getting handled, then that is a bug, and the work around is to declare the event at the Application controller level. Never declare an event at the Application level that then finds the controller at the Page/Data controller level and calls it. That even can end up getting fired twice. Application Storage and Deployment Maximo Application Framework applications are built using the Graphite tooling, packaged into binary files and added to the Maximo database. Applications are stored in the MAFAPPDATA table with the app id, binary file, version, revision and checksum, among other items. The version comes from a build.json file in the app binary while the revision and checksum are calculated when the binary is uploaded. Here is a sample of records found in the MAFAPPDATA table.

UPDATEDB==>Automatically inserts application zip files into the database if they are new Maxdev-cli Upload-app Developers can use the maxdev-cli upload-app command to manually package and upload an application zip file to Maximo Either method requires the uploaded zip file to follow a naming convention that includes the app id and its version, {appId}ver-{version}. For example, a zip file for the maxdemo-app that was created using Graphite build 2.442 will have the name maxdemo-appver-2.442.zip. The appid and version values that are stored in the database are generated by parsing the zip file name.

UPDATEDB==>When UpdateDB is run, it checks for zipped application binaries in the tools/maximo/en/graphite/apps folder and inserts them into the database if they are new. To do this, UpdateDB uses a new 'callout class' feature which invokes two hooks when installing products, beforeProductInstall and afterProductInstall. Graphite’s callout class, specified in the graphite.xml, implements the afterProductInstall method to find and insert the zip files into the database. Maxdev-cli Upload-app

THE UPLOAD-APP COMMAND WILL ZIP THE BUILD/APP/BUILD DIRECTORY OF THE GRAPHITE APPLICATION AND PUSH IT UP TO A RUNNING MAXIMO INSTANCE USING THE GRAPHITEAPPSERVICE. THE COMMAND SHOULD BE RUN FROM THE APPLICATION DIRECTORY IN VSCODE - TYPICALLY SOMETHING LIKE GRAPHITE/PACKAGES/MAXDEMO-APP, AND THE COMMAND SYNTAX IS AS FOLLOWS:

npx @maximo/maxdev-cli upload-app -u user -p password -a maxdemo-app Where -u and -p specify a valid Maximo username and password of the user deploying the application, and -a specifies the app id. The --no-context flag should be set when uploading to a maximo server without a context root set ('maximo' is the default context, another can be specified with --context).
npx @maximo/maxdev-cli upload-app --help The yarn site:build script assembles all of files required to run the application and places in the 'build/app/build' directory a build.json file containing the version of Graphite that was used to generate the application. The version is required by the upload-app command to generate the zip file name using the {appId}__ver-{version} convention. MAFAPPDATA Insert Rules Regardless of whether UpdateDB or the maxdev-cli is used to add an application, duplicates will not be inserted into the Maximo database. The version and checksum of the binary data are compared to existing MAFAPPDATA records to determine if a new record is needed, and the insert is skipped if they match.

If neither the checksum or version matches…​ a new record is created with the new version, and revision = 0 If the upload checksum matches but the version does not…​ a new record is created with the new version and revision = 0 (this means the binary matches one from another record - but since the versions are different it could indicate that a change was rolled back) If the version matches but the checksum does not…​ a new record is created using the version, but revision is incremented (this indicates that a new app zip was generated with the same version of Graphite) Application Deployment Applications are served from the file system and are expanded under a maf/apps directory. The directory is within the webserver domain*, but for development an alternate location can be specified with the MAF_APP_ROOT environment variable. When an application is requested, the binary for the current version and revision is expanded to the file system if it not already present. The directory name for the application’s contents follows the naming convention: MAF/apps/{app id}/{version-revision}.

GRAPHITE APPLICATIONS ARE INVOKED USING AN OSLC ROUTE HANDLER. THE ROUTE IS CALLED 'GRAPHITE', SO THE FOLLOWING URL CAN BE USED TO INVOKE THE 'MAXDEMO-APP' GRAPHITE APPLICATION:http://localhost:7001/maximo/oslc/graphite/maxdemo-app If the user is not yet authenticate to Maximo, the user is redirected to login app and then returned to the original requested app once authenticated. Application Data Cleanup Cron Task The MAFAPPDATA records and application binary files can consume a lot of space, so a Maximo cron task called 'AppDataCleanup' is available to clear out stale application data. It keeps the MAFAPPDATA table from filling up with application records, and keeps the webserver’s maf directory from filling up with unused application code.

Application code in the webserver’s maf directory that applies to an inactive revision is deleted. If the particular revision is made active at a later point, the code will be re-expanded to the file system.

THE MAXREVISIONS CRON TASK PROPERTY IS USED TO DETERMINE HOW MANY REVISIONS (PER VERSION OF AN APPLICATION) TO KEEP:
If MaxRevisions = 0, deleting revisions is disabled. The cron task will never delete the ACTIVE or 0th revision of an application, regardless of the MaxRevision setting.



USAGE EXAMPLE:IF MAXREVISIONS = 2 AND THERE ARE 4 MAFAPPDATA RECORDS, THE NUMBER OF RECORDS THAT WILL BE DELETED IS 2. ASSUME THE MAFAPPDATA TABLE HAS THE FOLLOWING CONTENT, WITH THE LAST REVISION IN ACTIVE STATUS:

Revision 1 and 2 will be deleted, leaving only revision 0 and 3 since the 0th and ACTIVE revisions cannot be deleted by the cron. Datasource Overview A datasource is data contract whereby the datasource allows the UI to depend on APIs that it exposes while delegating the actual loading of data to other implementations. Graphite provides a <json-datasource> which is a general purpose datasource for working with generic JSON data. Graphite also allows you to create other more specific kinds of datasources if needed. For example, for Maximo there is a <maximo-datasource> that offers additional attribute and has knowledge on how to communicate with Maximo via Maximo’s REST apis to load and save data. Applications can use Graphite with just the <json-datasource> and this section focuses on using that datasource to work with data. A key thing to know about datasources is that when you define a datasource with an ID that ID becomes the global name from which you can access the datasource. <json-datasource id="peopleDS" src="people.js"/> <field value="{peopleDS.item.firstname}"/> peopleDS can be accessed from the xml UI, and .item will always be the current item of the datasource.


STATE==>In much the same way that page and app have state, datasources also manage stateful properties that can be used from the declarative UI. The complete list of stateful properties include Using datasource state in the UI means that you can do things like tie a loading indicator to the datasource.state.loading or show the selected item count using datasource.state.selection.count. Loading Data The json-datasource can load data in several different ways, and this section will discuss all the ways in which data could be loaded. Loading Static Data In the most basic form, the json-datasource could load data in the following way. <json-datasource id="ds" src="data.js" /> The expectation here is that data.js would return an array of records. const data = [ { _id: 0, name: 'peter', moveddate: '2020-01-31T00:00:00-05:00', address: { city: 'London' }, }, { _id: 1, All data must define a unique id and by default it will look for _id as the unique identifer. Data loaded in this way can be filtered, sorted, searched, etc, but adding and removing records will be problematic since you can add and delete, but, only in memory. This is a very useful way to quickly bootstrap an application with data for a demo or POC. Dates are always in ISO8061 format with TimeZone information. Loading Dynamic Data In most real cases, you will need to load data from some actual remote server, and if all you need to do is read the data and not update it, then using a custom loader function is likely the simplest solution that also offers some advanced features. We still create the datasource the same way. <json-datasource id="ds" src="data.js" /> But the javascript code will return a loader function that is an async function that accepts a query and returns a response. const loader = async (query) => { return { let itemResp = await fetch('/loadadata); return { items: await itemResp.json() } }; }; export default loader; Given that you are an async function, you are free to load data however you please and take as much time that is needed. Understanding the query and response are key here.


QUERY==>A query is a json object that includes ANY of the following information. If you are given a qbe it will likely have come from the Table or set from the controller code, and it will be in the following format. {siteid: {value:"BEDFORD"}, assettype:{operator:"in",value:["PUMP","IT"]}, assethealth: {operator:">", value:20}} A QBE is like a structured where clause where the data is anded together. Your loader can choose to ignore any or all of the information in the query and just return data. The json-datasource will still do searching and filtering etc. In this way your loader is just behaving as a means to bulk load data. But if you do need or want to page the data coming back, you can choose to implement the start and size query params. It is perfectly ok to send back more than what was requested. Just the UI will tell you explicitly how much it needs and you can choose use that information or not.

RESPONSE==>The response from a dynamic loader is flexible as well. If you return an array of items, then we assume you have given us all your data. If you choose to send back an object then you can better manage further requests. The response object can have any of the following fields, but the items is the only required field. Typically start and end are not fields that you need to set, but the total is very useful. If you set a total the Datasource will use that as a means to know if it should ask you for more data or not. If you don't set a total we assume you've given us all your data. Handling Changes A json-datasource will manage changes, but those changes are simply kept in memory and can be discarded at any time. If you have a need to manage changes to the datasource then you can use a custom-datasource with your DataAdapter implementation which allows you full control over all aspects of the data loading and management lifecycles. Creating a custom data adapter from scratch would mean that you are managing the entire operations of the datasource such as filtering, searching, sorting, paging, deleting, saving, etc. There may be reasons to do this, but, you can also just extend the JSONDataAdapter and then choose override certain key methods of the DataAdapter. A custom datasource might look like this. <custom-datasource id="dsTodos" data-adapter="CustomJSONDataAdapter" /> import { JSONDataAdapter } from '@maximo/maximo-js-api'; class CustomJSONDataAdapter extends JSONDataAdapter { async getJsonResponse(query) { let data = await fetch('/todos/'); let json = await data.json(); let resp = { items: json, }; You can still choose to implement methods such as bulkPut or bulkDelete if you need to manage sending changes to the server, but the base JSONDataAdapter can manage the sorting, filters, etc. Reset Datasource State We have provided the flexibility to enable the ability to automatically reset the state of the datasource defined on a lookup, page or dialog. The reset-datasource property on a datasource defintion in the declarative UI (app.xml) triggers a dialog or page to reset the state defintion of the datasource back to its original state. The datasource will be reset when a page is resumed or when a dialog is opened a second time. The reset-datasource property on a lookup definition, triggers the datasource defined on the lookup to reset it state every time the lookup is reopened. If a datasource contains the `reset-datasource` property and its enabled, that datasource will have its state reset if its defined on a page or on any parent element of that page. The datasource will not be automatically loaded at this time. We will only reset the state. USE CASE #1 (Dialog stays open, Lookup is Re-Opened) A user wishes to clear the last search that was performed in a lookup that is defined on a sliding-drawer (aka Dialog). Everytime the lookup is closed and reopened while remaining on the dialog they want the lookup to be reset and not contain the previous search. Currently, when the lookup is opened and a search is performed, the state of that search is retained when the lookup is closed and reopened while still on the dialog. In order to clear the last search, a user can include and enable the reset-datasource property on the lookup as seen below. Every time the lookup will be opened the datasource state will be reset allowing the user to preview a fresh lookup again. <lookup id="laborLookup" show-search="true" reset-datasource="true" lookup-heading="Labor" datasource="laborDs" border="true" on-item-click="selectLabor" lookup-attributes="{['laborcode','displayname']}" height="400" width="60"/> USE CASE #2 (Lookup is closed, Dialog is Re-Opened) A user wishes to retain the last search that was performed in a lookup that is defined on a sliding-drawer (aka Dialog), so that if they re-enter the lookup the previous search results would still be there, but only while they remain in the dialog. When the dialog is reopened the user requires that that lookup data is reset. Currently, when the lookup is opened and a search is performed, the state of that search is retained when the lookup is closed and the dialog is closed. In order to clear the last search, a user can include and enable the reset-datasource property on the datasource that is defined for the lookup as long as the datasource exists in the dialog or within a parent element all the way up the application. After the dialog is initialized and re-opened all datasources on the diaog are checked to determine if their state should be reset. In the example below the `laborDs` datasource will have its state reset, but `woTaskds` will not, when the Dialog is reopened. <page> <dialogs id="wvvzx"> <sliding-drawer id="reportTimeDrawer" align="start" header-text="Labor" content-padding="false"> <maximo-datasource id="laborDs" reset-datasource="true" object-structure="mxapilabor" saved-query="LABORSITEMOB" selection-mode="single" lookup-data="true"> <schema id="j8qp2"> <attribute name="laborcode" id="m3ypr" searchable="true"/> <attribute name="orgid" id="m3xd5" index="true"/> <attribute name="person.displayname--displayname" searchable="true" id="zvvv6"/> <attribute name="laborid" unique-id="true" id="x4j_b"/>



IN THE FOLLOWING EXAMPLE, WHEN THE SLIDING DRAWER IS OPENED A SECOND TIME, THE FOLLOWING DATASOURCES WILL HAVE THEIR STATE RESET:
1. The `laborDs` datasource defined  on the sliding drawer will be reset. 2. The `priorityds` datasource defined on Page1 will be reset. 3. `woasset` and `wolocation` will both be reset on the application. The logic traverses up the tree resetting the state of any datasource found on the current element and all the way up for each parent element. <maximo-application> <maximo-datasource id="woDetailds" object-structure="mxapiwodetail"/> <maximo-datasource id="woasset" reset-datasource="true" object-structure="mxapiasset"/> <maximo-datasource id="wolocation" reset-datasource="true" object-structure="mxapilocation"/> <pages id="pages"> <page id="page1"> <maximo-datasource id="priorityds" reset-datasource="true" object-structure="mxapilocation"/> <maximo-datasource id="statusds" object-structure="mxapilocation"/> <dialogs id="wvvzx">


CONTROLLERS==>A datasource can accept a controller JavaScript class that can listen for events on the datasource. <json-datasource controller="DataController" id="ds" src="Data.js" /> class DataController { onValueChanged() { // do something } } export default DataController; onDatasourceInitialized(Datasource) Called when the datasource initializes. You get access to the datasource, and you might choose to manipulate the options, or query, etc. onBeforeLoadData(Datasource, Query) Called before the datasource loads data. You can manipulate the query. onAfterLoadData(Datasource, Item[], Query) Called after data is loaded and you get the items. This is used most frequently to manipulate data in the items array. eg, you might need to add in custom fields or manipulate the response before it goes to the datasource. onLoadDataFailed(Error, Datasource, Query) Called if the data load failed. onBeforeSaveData({datasource, items, throwError}) Called before saving data. Gives the app controller an opportunity to inspect/manipulate the data being saved. onAfterSaveData({datasource, items, hasNewItems}) Called immediately after the save is successful and can indicate if there are new items as a result of the save. onSaveDataFailed({datasource, items, warnings}) Called if the data fails to save. It will include the list of warnings that prevented the save. onBeforeAddData({datasource, item, options}) Called before add is called. Gives the app controller an opportunity to inspect/manipulate the data being added. onAddDataFailed({datasource, item, error}) Called if the item fails to be added. It will include the list of warnings that prevented the add. onBeforeAddNewData({datasource, options}) Called before addNew is called. onAddNewRecord({datasource, item}) Called after the addNew is called and the item is added to the datasource. onAddNewFailed({error, datasource, response}) Called if the add new fails. It will include the error that prevented the call, as well as the full response. onValueChanged({datasource, item, field, oldValue, newValue, changes}) This is the most commonly used event. It is called after data has changed on a field in a datasource. It allows for an opportunity to reject the change, and while you can’t reject it (it already happened), you can use some additional datasource APIs to alert the user of failures, etc. datasource.setWarning(item, field, message) could be used to set a warning on the field. You could also reject the change by simply replacing the new value with the old value. onValueChanged({datasource, item, field, oldValue, newValue}) { if (field === 'price') { if (newValue > 100) { datasource.setWarning(item, field, 'The cost of $100 is too high'); } if (newValue < 0) { item[field] = oldValue; } } } `smart-input` elements in the UI automatically listen for datasource field warnings and will show the warnings automatically if they are set. Depending on other Datasources Graphite can use a variety of datasource, even though out the box, it only provides, <json-datasource>, <custom-datasource> and a <maximo-datasource>. Independent of the type, datasources can depend on each other, which offers a loading contract for loading data. Consider the following 3 datasources. <json-datasource id="ds1" src="data1.js"/> <json-datasource id="ds2" src="data2.js" depends-on='ds1'/> <json-datasource id="ds3" src="data3.js" depends-on='ds2'/> When ds3 is asked to load, if it has a dependency it will force its dependent datasource to load first, and the chain will continue until there are no more dependencies. The ds3.state.loading will be held to true until the chain of data is loaded. This doesn’t cause a force load of the dependent data. If the parent (depends-on) has data then it will just return quickly allowing the child to load. A common use for for depends-on is that you want to create a json-datasource from another datasource. As such, your datasource needs to depend on the depends-on datasource and after the depends-on is fully loaded you can then use the information from the depends-on datasource in your current datasource. depends-on is simply a way to enforce a loading contract between data.

SCHEMA==>Datasources support the concept of a schema. The schema is an enhanced w3c json schema offering support for a richer set of datatypes, field titles, field help, etc. The UI component will use information from the schema, if it is present. ie, if a smart-input is bound to an item that has schema information, then that smart-input will use that information to determine the input control to render, show the field title, and provide field help. Providing schema information reduces the amount of information that an app developer needs to provide in the UI when referencing components. When building custom datasources the schema information can be returned as part of the response. A JSON response will include items but it can also include a schema property as well. The schema if being returned from the loader or DataAdapter should be in the following example format. schema: { $schema: 'http://json-schema.org/draft-04/schema#', resource: 'MXAPIINSPRESULT', description: 'Maximo API for Retrieving\u00a0Inspection\u00a0Result', pk: ['resultnum', 'orgid', 'siteid'], title: 'INSPECTIONRESULT', type: 'object', $ref: 'oslc/jsonschemas/mxapiinspresult', properties: { As an example, if you use a smart-input as in the examples that follows, it will automatically know the type, title, and help, automatically from the schema. <smart-input value="{item.locations.location}"/> Likewise, using a field bound to an item that schema information will automatically format that data and provide the field label based on the schema. <field value="{item.duedate}"/> smart-input components will also use the required segments to ensure that required fields are marked as required. The goal of the schema is allow the application developer to provide as little information as possible at the time the data is used, and allow the framework to inject titles, type validation, help, etc. Defining Schema in the Declarative UI While a datasource can provide schema, the application UI can also define the schema and even enhance the schema that is returned. This is commonly used for json-datasource when the server (or mock data) is not providing any schema information. Datasources will use a schema sub element as a means to define the schema for the given data. The schema, when defined on a datasource might look like this. <json-datasource id="persons"> <schema> <attribute name="personid" unique-id="true"/> <attribute name="displayname" searchable="true" title="Display name" required="true"/> <attribute name="firstname" title="First name" remarks="First name of the person"/> <attribute name="lastname" title="First name"/> <attribute name="address.addressline" title="Address line"/> <attribute name="address.city" title="City"/> <attribute name="address.stateprovince" title="State" remarks="State or province"/> If the persons defines a schema then the schema in the xml will be merged in with the existing schema overriding any common attributes. Nested objects can be defined in dot notation as in the above example, or as child nested attributes. <json-datasource id="persons"> <schema> <attribute name="personid" unique-id="true"/> <attribute name="displayname" searchable="true" title="Display name" required="true"/> <attribute name="firstname" title="First name" remarks="First name of the person"/> <attribute name="lastname" title="First name"/> <attribute name="address"> <attribute name="addressline" title="Address line"/> <attribute name="city" title="City"/> While the schema is very important to Graphite for validation, rendering, etc, it also serves a great way to document in the application xml the information that is being used. Schema Attribute Properties Computed and non persistent attributes You can define attributes in the Schema that are not a part of the data set coming from the remote server. Using the persistent="true" option is way to tell the dataadapter to not save or persist that information. Computed fields are slightly different. Computed fields are read-only with only a getter. You can set Common Datasource APIs Common Datasource APIs for use with JavaScript Controllers This section offers some of the common patterns that is needed for accessing a datasource Finding a Datasource The best way to access a datasource is to use app.findDatasource(name) which will find the datasource at the Application or Page scope. let ds = app.findDatasource('persons'); ds.load(); Force loading a datasource A datasource will only reload if it detects changes to the query. If you need to forcefully reload the information, you can call forceReload() let ds = app.findDatasource('persons'); ds.forceReload(); Searching a datasource You can search a datasource and optionally pass a set of fields on which to search. Omitting the second param will simply allow the datasource to decide on which fields to search. let ds = app.findDatasource('persons'); ds.search('Tom', ['displayname']); Search using QBE QBE (Query by Example) is a way to search multiple fields on a datasource using a simple expression for each column let ds = app.findDatasource('persons'); ds.searchQBE({ age: '>10', updated: '>2020-01-01', }); Iterating over data You may have cases where you need to iterate over the items in the datasource. let ds = app.findDatasource('work'); await ds.forceReload(); let totalCost = 0; ds.forEach((item) => (totalCost += item.cost)); page.state.totalCost = totalCost; Item selection Some controls like a data-list or table can manage selections. From controller code, you can get selected items, or even select or unselect items. let ds = app.findDatasource('work'); // get a list of selected items let selected = ds.getSelectedItems(); // clear all selections ds.clearSelections(); // select an item Get an item You can access items in the Datasource using the .items property or the .forEach method, but you can also directly access an item. let ds = app.findDatasource('work'); // get the first item ds.get(0); // get an item by it's unique id // finds the loaded item where _id='A1000' ds.getById('A1000'); Saving changes Datasources can have an option for auto-save which by default is true. When auto-save is enabled the datasource will call .save() automatically when items change. If auto-save is false, then you can make changes and call save programmatically. let ds = app.findDatasource('work'); let item = ds.get(0); item.description = 'A new description'; item.status = 'APPR'; ds.save(); Undo changes If a datasource does not auto-save you can programmatically undo changes. let ds = app.findDatasource('work'); let item = ds.get(0); item.description = 'A new description'; item.status = 'APPR'; let item1 = ds.get(1); item1.description = 'A new description'; item1.status = 'CANCELLED'; QBE Filtering

OVERVIEW==>A QBE is an acronym for Query By Example. In short, it is a simple API for searching based on setting fields with values and avoiding knowing how the create SQL statements or other internal searching APIs. QBE filtering allows you to quickly filter a datasource by adding a QBE section within a JSON or MAXIMO datasource declaration in the app.xml. Example of a QBE section. <qbe id="najey"> <qbe-field name="person" value="WILSON" id="d9m2q"/> <qbe-field name="address" value="FRANKLIN" id="nnr2d"/> <qbe-field name="age" operator="<" value="50" id="kwa24"/> </qbe> A schema is required in order to apply the QBE properly. Since the schema of a datasource is not loaded upfront, you will need to define the schema for each attribute in the app.xml, so its schema attribute properties can be used to determine the type of QBE search to perform either WILDCARD or EXACT and whether or not to wrap the value in quotes. If you wish to perform a wildcard search on a field, you can mark the schema attribute with a search-type of WILDCARD. When the search-type is defined to be a WILDCARD, the value will be wrapped with % characters. Example: "%PUMP100%". When the search-type is defined to be EXACT or anything else, the value will be wrapped with quotes when the schema is defined as a type of string. When the schema is defined as a numeric the value will not be wrapped in quotes. The operator property is not required by default. When an operator is not provided it will default to ”=“. If a QBE field attribute is not found in the schema, it will be considered as a string with an EXACT search type. When multiple QBE fields are defined they will be appended together using “and”. Example of a QBE section within a datasource. <json-datasource> <schema id="b8rz5"> <attribute name="person" search-type="EXACT" searchable="true" id="zjng9"/> <attribute name="age" searchable="true" title="Age" type="NUMBER" id="aa8xq"/> <attribute name="birthdate" searchable="true" id="a88dy"/> <attribute name="address" search-type="WILDCARD" searchable="true" id="dwvpn"/> </schema> <qbe id="najey"> <qbe-field name="person" value="WILSON" id="d9m2q"/> The following illustrates the query that will be generated from the above qbe definition and appended to the existing where clause: person="WILSON" and address="%FRANKLIN%" and age<50 QBE Field Attribute Properties


The following example attributes would be defined in the schema section of the datasource to be used by the QBE fields in the examples below.THE FOLLOWING QBE FIELD EXAMPLES USING THE SCHEMA SUB-TYPES ABOVE:QBE Range Queries A range query enables data to be filtered using a single attribute defined with a beginning boundry and an ending boundry. Typically the boundry value is either a numeric or a date/datetime value. Example #1: QBE section within a datasource that includes QBE range filtering with (age) INTEGER <json-datasource> <schema id="b8rz5"> <attribute name="person" search-type="EXACT" searchable="true" id="zjng9"/> <attribute name="age" searchable="true" title="Age" type="INTEGER" id="aa8xq"/> <attribute name="birthdate" searchable="true" id="a88dy"/> <attribute name="address" search-type="WILDCARD" searchable="true" id="dwvpn"/> <attribute name="city" searchable="true" id="ssd887"/> </schema> <qbe id="najey">

THE FOLLOWING ILLUSTRATES THE WHERE CLAUSE THAT WILL BE GENERATED FROM THE ABOVE QBE DEFINITION AND APPENDED TO THE EXISTING WHERE CLAUSE:
city="BOSTON" and age>18 and age<21 Example #2: QBE section within a datasource that includes QBE range filtering with (birthdate) DATE <json-datasource> <schema id="b8rz5"> <attribute name="person" search-type="EXACT" searchable="true" id="zjng9"/> <attribute name="age" searchable="true" title="Age" type="INTEGER" id="aa8xq"/> <attribute name="birthdate" searchable="true" sub-type="DATE" id="a88dy"/> <attribute name="address" search-type="WILDCARD" searchable="true" id="dwvpn"/> <attribute name="city" searchable="true" id="ssd887"/> </schema> <qbe id="najey">

THE FOLLOWING ILLUSTRATES THE WHERE CLAUSE THAT WILL BE GENERATED FROM THE ABOVE QBE DEFINITION AND APPENDED TO THE EXISTING WHERE CLAUSE:
city="BOSTON" and birthdate>"1970-01-01T23:59:59" and birthdate<"1980-05-15T00:00:00"

A DATE WITH A TIME (DATETIME) CAN ALSO BE USED AS BOUNDRIES AS WELL, INSTEAD OF JUST USING A DATE. THE SCHEMA CAN BE UPDATED TO USE A SUB-TYPE OF DATETIME AND THE QBE FIELDS CAN BE DEFINED AS BELOW:<qbe-field name="birthdate" operator=">" value="1970-01-01T00:00:00" id="q32q2"/> <qbe-field name="birthdate" operator="<" value="1980-05-15T23:59:59" id="qwvk6"/>

QBE API==>Datasources have always supported a setQBE method. The XML declaration is just a way to set this from the XML vs JavaScript code. The format of the setQBE API is as follows, setQBE(field, operator, value, isRange) ds.setQBE('startdate', '>=', '2020-10-30'); let items = await ds.searchQBE(); If you want to set a range QBE, you can do the following. ds.setQBE('startdate', '>=', '2020-10-30'); ds.setQBE('startdate', '<=', '2020-11-30', true); let items = await ds.searchQBE(); Passing true as the last parameter signifies this is a range query. A Datasource’s DataAdapter will need to know how to process QBE queries. The Maximo DataAdapter and the JSON DataAdapter both understand the QBE format. If you have a custom DataAdapter that extends either of these then they will automatically be able to process QBE queries. Timeline Queries

A timeline query is a query against a field that specified a relative time. For example you might want all work created in the last 7 days. Datasources have a set of default timelines, but there are APIs for creating additional timelines. Timeline queries are implemented using the setQBE range apis and should be compatible with Mobile disconnected data queries. Using timeline queries To apply a timeline query to the datasource, you can use the following API, applyTimelineQuery(query, field, relativeTo), where query is the timeline queryId or query object, and field is the field to which to apply the query, and the relativeTo is the ISO date from which to apply the query. ds.applyTimelineQuery('last6months', 'createddate'); If the relativeTo is omitted then it will assume the current date and time. If you want to specify an alternate relativeTo you can provide it as an ISO Date string. ds.applyTimelineQuery('last6months', 'createddate', '2021-11-15'); You can also provide an ad hoc timeline query, ie, a query that is not officially registered with the Datasource, by simply passing the Timeline query object as the first parameter. ds.applyTimelineQuery({ query: '-2y' }, 'createddate', '2021-11-15'); The above query would apply a time range for the last 2 years from the supplied relative date. Queries are fully bounded, in that they obey the following contract. start >= timerange <= end Meaning that the query will included everything greater than and equal to the start and less than and equal to the end. Integration into the UI Some components, if they automatically support timeline queries, will show a dropdown of queries and when selected it will re-query the datasource automatically. The components are not listed here, but if you see a component showing a dropdown of queries like “Last week” then it is likely it is coming from the Datasource to which that component is attached. Customizing and adding your own timelines Timelines are stored in the Datasource’s timelineQueries field. Out of the box there are several default queries, but you can supply additional ones, or remove existing ones, if you hook into the Datasource’s onDatasourceInitialized event. For example if you wanted to add your own queries and remove the existing ones you could do the following. onDatasourceInitialized(ds) { ds.timelineQueries.length = 0; ds.registerTimelineQuery({ id: 'last3months', label: 'Last 3 months', query: '-3m' }); ds.registerTimelineQuery({ id: 'next3months', One advanced feature of the registerTimelineQuery is that your query can also be a function. If you supply a function, then the query will show up in the list like any other timeline query, but when you select it, your function will be called. This would allow you to create a query in the list that slightly more complex than a simple range query. onDatasourceInitialized(ds) { ds.timelineQueries.length = 0; ds.registerTimelineQuery({ id: 'lastquarter', label: 'Last quarter', query: (datasource, queryObject, timelineField)=>{ // do some fancy calculations and the call datasource.load() or datasource.searchQBE(), etc } }); Custom query functions will be called with the datasource instance, the query object, and the timeline field on which to apply the query. Timeline Query Format The query field when supplying a text query is in the format fieldname sign number duration Some examples include -7d - last 7 days +7d - next 7 days changed -6m - last 6 months relative to the current value of the item.changed field. When supplying a field in the query, you asking that the timeline be applied relative to the current value of that field. So the relative to is no longer the current date and time, but rather relative to the current value of the given field on the current item. Complete list of duration identifiers At a very minimum a query text much include the sign, number and duration. Javascript Overview


Graphite applications use vanilla javascript for controllers. This means that the javascript code does not depend on things like React, Angular, etc. The goal of this section is not to teach JavaScript. There are many online JavaScript tutorials and courses. This section will focus on some best practices and common pitfalls and how to avoid them. Async and Await Promises are the lifeblood of performant code. They allow us to defer or pause execution of a function until some time in the future when data arrives, and continue the execution of our code. Javascript is single threaded, so without Promises you would have long pauses in the UI as data is being fetched, etc. The single threaded nature of javascript simplifies the thread model and allows us to easily predict what will happen, given there is only a single thread. A challenge for some developers is failing to understand what happens when a promise is called and how it can adversely affect your code and tests. This section attempts to explain some of the nuances of using promises. Using async pageResumed lifecycle method It is perfectly ok to have a lifecycle method declared as async, but you need to understand what that means. When a page is resumed, the pageResumed lifecycle method is called on your page and/or app controllers. If the pageResumed methods are declared as async then that code gets executed after the initialization. The resume/initialize lifecycles will not await on these methods since they are not expected to be async. So if you do something in an async pageResumed, it is expected that you don’t care when it happens - just that it will happen at some point in the future. This happens because javascript is single threaded, i.e. the thread runs until it completes or it hits an await. When that happens any promises are run and if they have await they are yielded and other code is allow to run. So if we conceptualize the initialize code to be something like this (It’s not like this, but greatly simplified here)… class Application { async initialize() { this.state.canRender =  false; this.currentPage.controller.pageResumed(page, this)) this.datasources.forEach(ds=>ds.controller.datasourceInitialized(ds, this)) this.state.canRender =  true; } } Nothing is awaiting on the pageResumed() method, so if it is async then no code is run in that method until all other code in the current execution block gets executed. And the graphite JSX code ends up doing something like this… await app.initialize(); // now allow the first render We can see that our async pageResumed() will actually get called sometime in the future after the page is rendered… and that might be ok but it is likely not if you needed something to happen in the pageInitialized before the application rendered. A common mistake is made when trying to setup the datasource before the page loads… using the following code the setup will actually happen after the first render. async pageResumed(page, app) { page.state.setSomeImportantState="ABC"; let ds = app.findDatasource("ds"); ds.setQBE('wonum',page.params.id) await ds.load(); page.state.afterDataLoadedSetSomeVar = ds.get(0); } Instead you can do this… pageResumed(page, app) { page.state.setSomeImportantState="ABC"; let ds = app.findDatasource("ds"); ds.setQBE('wonum',page.params.id); loadData(); } async loadData() { await ds.load(); It is subtle but in the second example the initial page state and datasource setQBE will all happen in the pageResumed, and only the datasource load and state you need to set after load will be run after the page renders. Another advantage with this second block is that if datasources need to be loaded after the page renders, the .load() is called automatically and is already setup with the initialization from the pageResumed. As written in the first problematic block, the datasource might be loaded twice. Show a page loading while waiting for data You might decide that you want to show a page loading indicator while you are waiting for your data to load. You can do this… pageResumed(page, app) { let ds = app.findDatasource("ds"); ds.setQBE('wonum',page.params.id); loadData(); } async loadData() { try { this.app.state.pageLoading = true; This ensures that the when the loadData() is called it turns on the page loading flag and keeps it on until all the data is loaded. The async on loadData() ensures that the code runs after the page has a first render. async with try / catch / finally A very common bug that I see many developers do is to call a promise inside a try/catch and not await on it. pageResumed() { try { loadData() } catch (ex) { page.state.error = ex; } finally { page.state.dataIsLoaded = true; } } At first glance it looks like any error thrown by the loadData() method will be caught, but that is not the case. If you can’t see why, re-read the code and trace through it as JavaScript would. You’ll see that all the try/catch code is in the primary main thead (non async), and once loadData() is reached javascript will simply create and submit the promise for it and then immediately continue executing the try/catch/finally code. The loadData is actually called after the try/catch/finally completes, so there is no longer anything listening for an error. To fix this, the code should be… pageResumed() { loadData() } async loadData() { try { let items = await this.app.findDatasource('ds').load(); page.state.setSomVarAfterLoad = items[0].wonum; } catch (ex) { In this code we can catch the error because we are awaiting on the .load(). To catch an error for a promise you must await on the promise to be resolved, or use .catch() on the returned promise. I’ve seen many unit tests incorrectly use a try/catch around an async function but the end result is a dangling promise in the test. If the function fails it can be almost impossible to figure out where and why. Resolve promises in unit tests For unit tests you need to make sure that you await on your async functions. You cannot just call it and forget it. Do not do this… it('works', async () => { callAsyncMethod(); await ds.load(); }); The callAsyncMethod() code will return immediately and run the promise later, usually after the test has finished. If callAsyncMethod() throws an error it will lead to a cryptic and hard to track down problem. For unit tests, be sure to always resolve promises before you finish the test. it('works', async () => { await callAsyncMethod(); await ds.load(); }); Do not leave any promises unresolved. Another common problem that I’ve seen in tests is failing to fully resolve a promise before a test exits. Consider the following code. it('works', async () => { await ds.load(); callAsyncMethod(ds.items).then(stuff=>assert(suff==='ok'))); }); At first glance this might seem OK, but the .then will get run after the test ends. Don’t mix and match async/await with old style promises. Another challenge of old style promises is failing to catch errors it('works', (done) => { ds.load().then(items => { callAsyncMethod(ds.items).then(stuff => { assert(suff==='ok') done() })); }); }); You might think the following code is OK because it’ll call done() once the second promise is resolved. But if there was an error in .load() or in callAsyncMethod(), then the promise is not resolved. You’d need to write this as… it('works', (done) => { ds.load().then(items => { callAsyncMethod(ds.items).then(stuff => { assert(suff==='ok') done() })).catch(ex => done(ex)); }).catch(done(ex)); }); Many developers completely forget about the .catch() part. You might think that it('works', async () => { await callAsyncMethod() // is the same as callAsyncMethod().then(( )=> //do something); } But these are subtly different. In the await statement if an error it thrown it will be caught by the test runner, because we used await. In the second line if an error happens it generally results in some unhandled promise rejection error that is hard to track down. Async functions that await on return While this is not technically bug, it is generally bad practice to do the following. async loadData() { let items = await this.app.findDatasource('ds').load(); return items; } await loadData(); Nothing about this function needs to be async, it can be written as… loadData() { return this.app.findDatasource('ds').load(); } await loadData(); As a general rule, if the last thing your function does is await on some other promise and then return the results, then you do not need to await at all - you just return the promise as-is. If we trace the code for this, what is likely going to happen in the first example is that loadData() is not called during the main execution but scheduled for execution later. In the next slice, loadData() may be called and then it runs until .load() is called, and then in some future slice when .load() completes the items data is converted to a Promise.resolve(items) and finally makes its way back to the caller of loadData(). At minimum it could be 3 slices before this happens and the actual .load() will not happen until the second slice. In the second example, the primary code that calls loadData() is executed immediately in this current slice - and runs until .load() is called - returning a promise directly back to the caller. In a future slice .load() is resolved and items are returned to the caller. This completely removes an entire slice (or thread wait loop) in the call chain, which might not affect performance to any degree but it may end up causing other timing side effects in your code. Mobile Supported Flag


Applications can be developed to be used on both Desktop and Mobile devices. There may be times where an application will be developed to be used only on a desktop (Example: Asset Health). The Graphite framework is built to be responsive no matter which platform you are running, either mobile or desktop. Developing for mobile sometimes requires extra effort either on the component side, backend framework, or mobile. Due to requirements at the time of development we may deliver desktop only functionality depending on resources and/or requirements. Some components do not make sense to be used on a small mobile device, but are more intended for larger displays that are primarily used on desktops. For these reasons, we prevent some components and properties from being used in a mobile application. The table component is one that works great on a desktop, but does not work well on a small mobile device. Since we do not support or recommend using the table component on a mobile device we have flagged it in the registry as not supported in mobile. Other components that are not supported in a mobile application at the time of this writing are Tables, Tabs, Flyouts, ProgressWizard, RadioButtons, PropertiesEditor. By default, all components are mobile enabled. Mobile applications run on desktop and mobile devices. Components and properties that are defined as `mobile-supported:false` that are referenced in the `app.xml` of a mobile application will throw an error during the build process.

THE BUILD WILL FAIL WITH RED ERRORS WHEN BUILDING A MOBILE APPLICATION (APP.XML) THAT CONTAINS COMPONENTS AND/OR PROPERTIES THAT ARE NOT SUPPORTED IN MOBILE WILL YIELD THE FOLLOWING ERROR MESSAGE:[ERROR]: The 'tabs' element with id, rnwrk, is not support on a mobile device. If you need to override use the 'use-with-mobile' property on the element. [ERROR]: The 'use-with' property on the 'table' element with id, dgfhs, is not support on a mobile device. If you need to override use the 'use-with-mobile' property on the element. Xxx keep above and remove below How to flag a component as not supported in mobile (component UI developer) When a component is being developed and the developer wants to prevent its usage on a mobile application, they will need to add the mobile-supported flag in the component’s registry file. The mobile support will be disabled when the developer adds the ‘mobile-supported’: false property to the root of the registry file. If the flag is not defined in the registry file the default will be to allow mobile support.
const registry = { name: 'table', description: 'A Table component which displays rows of data.', category: 'list', 'mobile-supported': false, If an app developer attempts to use a component that is not supported in a mobile application they will receive an error at build time indicating that the component is not supported. How to flag a specific property of a component as not supported in mobile (component UI developer) Similarly, support has been added to flag a component’s property as not supported on a mobile application. In this case, a component will be allowed on a mobile device, but one or more of its properties may not be supported in mobile. The mobile-supported: false flag can be added to one or more properties of a supported component. This will allow the use of the component but prevent certain properties from being used on the app.xml. In the example below, the maximo-datasource registry file has two properties defined as not supported in mobile. The controller and cache-expiry-ms are not supported in the fake example below.
name: 'maximo-datasource', description: 'Datasource Implementation that can be used for testing.', category: 'data,maximo', props: { id: { type: 'string', description: 'The unique id name for the maximo datasource.', required: true If an app developer attempts to use a property that is not supported in a mobile application they will receive an error at build time indicating that the property is not supported. Dates and Times Maximo supports field types that can represent dates, times, date/time, and duration. The use cases for each field can be explained as such.

You need to capture a date that is static no matter what timezone in which it might be viewed. e.g., Christmas is December 25, 2022 for all people no matter which timezone it is viewed. If that DATE is entered into a system, and someone views that date in a different TimeZone, it’s not Dec 26, 2022 for some and Dec 24, 2022 for others, it’s always Dec 25, 2022. The same would be true for capturing a birthdate, in that it would not change based on who is viewing the date. There are very few cases where a Date should be used on its own.

Time is even more problematic in that I can’t think of a use case for storing a time without a timezone. That being said, Maximo does this, and the best place to see it in action is with Shifts. They have a start time and an end time, and no matter what timezone you are viewing it in, it is always the same start and end times.

This is the most common format for anything date and time related. It stores the date and time along with the timezone so that it can be accurately displayed for any end user in their timezone.

Durations are numeric decimal values that represent hours. ie, 1.5 is 1:30 or 1 hour and 30 minutes. It is used to store how long something happened or might happen. For example, a DURATION on a work order might be 8.0, indicating an 8 hour duration. How Maximo handles Dates and Times

Maximo stores the DATE value with a timezone of the server. Because the Timezone information is not relevant for this type, if I set Dec 25, 2022 as a user in any timezone, then maximo stores Dec 25, 2022 + Server Timezone. Maximo does not do TimeZone conversions on these fields. Maximo will strip the time and store is as 00:00:00, no matter what original TIME existed for the value. Given this, if I want all users of the system to see the same date in all timezones, you need to provide the date in the server’s TimeZone.

Behaves exactly like the DATE type, except that only the TIME is preserved and it is stored in Maximo in a DATETIME sql type and in the TimeZone of the server. No TimeZone conversion is done on this field. If you send 11:00am in the user’s GMT-5 timezone then maximo stores 11:00am in the server’s timezone without converting. Maximo will strip the Date from the field and replace with a common start time (Jan 1, 1970), but preserve the TIME information without respect of the TimeZone.

These are stored in the database in a sql DATETIME type using the server’s timezone. If the time comes in with a different timezone as the server then it is converted from the timezone (usually the user timezone) to the server timezone, and that value is stored. The REST APIs and Maximo Date and Times As a general rule, DATE, TIME and DATETIME values are all sent from the server to the client in the server timezone (ie, the timezone in which they are stored). In all 3 cases, if you store any of these values and you send to Maximo a TIMEZONE and the TIMEZONE is different than the server timezone then Maximo will convert from that timezone to the server timezone and store that converted value. This can be problematic, since, for DATE and TIME objects we don’t want any conversion to happen. For this reason when sending DATE and TIME values we should strip the TIMEZONE information before sending to Maximo. When Maximo receives Date and Time values without TIMEZONE information it will use the Server timezone. In this case if the user enters 3am then Maximo stores 3am and when viewed by all users of the sytem they all see 3am. What happens if you mix and match timezones

Let’s consider that you are creating a form to update Calendar Shifts. There is a starttime and endtime field, each with a TIME type. TIME: Scenarion 1 - We send timezone information User is in -05:00 and the server is in 00:00. User enters a starttime of 10am, and 1970-01-01T10:00:00-05:00 is sent to the server. The server stores 1970-01-01T15:00:00+00:00. When the same user loads that record and views it, they will get 1970-01-01T15:00:00+00:00 from the server and we’ll convert their timezone and show 1970-01-01T10:00:00-05:00 (10am). Everything seems great. Another user in +12:00 timezone comes along and views the time. Server sends back 1970-01-01T15:00:00+00:00 and they covert their time zone and get 1970-01-02T03:00:00+12:00 (3am). This results in an error, since the TIME has be timzone agnostic. They should be seeing the same 10am time that the first user entered. TIME: Scenarion 2 - We send timezone information on send but strip it when viewed User is in -05:00 and the server is in 00:00. User enters a starttime of 10am, and 1970-01-01T10:00:00-05:00 is sent to the server. The server stores 1970-01-01T15:00:00+00:00. When the same user loads that record and views it, they will get 1970-01-01T15:00:00+00:00 from the server and we show 1970-01-01T15:00:00-05:00 (3am). That’s not right. Now the user hit’s save and they send back 1970-01-01T15:00:00-05:00 to server, and it converts to server time and we end up with a scenario of that every time the user loads and saves the time we keep incrementing/decrementing the value because of the inconsistent timezone handling. TIME: Scenarion 3 - Timezone is ignored User is in -05:00 and the server is in 00:00. User enters a starttime of 10am, and 1970-01-01T10:00:00 is sent to the server. The server stores 1970-01-01T10:00:00+00:00. When the same user loads that record and views it, they will get 1970-01-01T10:00:00+00:00 from the server and we strip the timezone and show 1970-01-01T10:00:00-05:00 (10am). Everything seems great. Another user in +12:00 timezone comes along and views the time. Server sends back 1970-01-01T10:00:00+00:00 and we strip the time zone and get 1970-01-01T10:00:00+12:00 (10am). Everything is good.

It should be clear by now, that DATE with follow the same timezone logic as TIME, and the TIMEZONE information should be stripped when sending to Maximo so that DATE values are stored in the server timezone without conversion. If you follow the previous 3 use cases but look at the DATE intead of TIME, we’ll see that date would be shifted between different timezones. ie, You enter 2022-02-11T10:00:00-05:00 if you send the timezone to Maximo, Maximo will store, 2022-02-11T15:00:00+00:00, and if you view that date as another user in another timezone (+12) you’ll now see 2022-02-12 instead of 2021-02-11. For this reason we send dates to maximo without the TimeZone and when we get a date from Maximo, the TimeZone is dropped and we show that date to the user in the same way it was stored in Maximo.

Since DATETIME values always use a TimeZone then you can send any timezone on the server and it will convert to the server timezone and if the server sends back a time it will have the server timezone and you can convert to the user timezone. There is never a problem when using a full datetime value with timezones. Graphite and timezones Graphite primarily uses the TimeZone of the Browser (which is derived from the TimeZone of the OS). For this reason, the Maximo User TimeZone should always be set to that of the Browser/OS. If you are doing TimeZone testing, this needs to be configured this way. While Classic maximo ignored the OS timezone, Graphite does not. And it it does not because most of the Date/Time handling is done via 3rd party components, like Carbon and PAL. To avoid a 3 way timezone conversion, introducing more points of failure, the Browser/OS timezone is used. Graphite also adds 2 new display date formats that are not defined in Classic Maximo. These include DATE_FULL_MONTH and DATE_FULL_DAY. When these are used it is assumed that these are DATETIME values (ie, timezone aware) and being displayed without TIME information. ie, DATE_FULL_DAY would display a DATETIME of 2022-02-11T10:00:00-05:00 like February 11, 2022. Drilldown n-levels using Hierarchical Datasources Setting Up an n-level Drilldown Datasource Graphite gives you the ability to navigate a tree structure of related data without having to define each level in the app.xml artifact. There are two pieces that are needed. A hierarchical datasource that has a relationship that fetches and checks if children exist. A datalist referencing the datasource mentioned above. Maximo-Datasource Properties Schema Attribute Properties Used When Defining n-level Hierarchy Datasources Datasource Schema Attributes Explained Further When the child-relationship is defined on an attribute, the datasource will wire up and incude an aliased count attribute (relationship-name._dbcount--childcount) as part of the select which will be used to check if children exist and enable the toggle to appear to show the next level of data. When the use-saved-query boolean is set to true an attribute defined with child-relationship, the saved query from the top-level datasource will be applied to all nested children. The default is false. When the child-saved-query is defined on an attribute with child-relationship defined, the saved query defined for the child will be used for all nested children. When the ctx is defined on an attribute with child-relationship defined, the saved query defined for the child will be used for all nested children.


DATASOURCE SETUP #1:In the following datasource setup, the n-level hierarchy will drilldown using the syschildren relationship. <maximo-datasource id="ddLocationDS1" object-structure="mxapioperloc" selection-mode="none" page-size="50" pre-load="true" include-counts="false"> <schema id="dmg3k"> <attribute name="location" searchable="true" id="yya3k"/> <attribute name="description" searchable="true" id="q88jn"/> <attribute name="status" id="vj5d6"/> <attribute name="locations" child-relationship="syschildren" id="xrprg"/> </schema> </maximo-datasource>


DATASOURCE SETUP #2:In the following datasource setup, the n-level hierarchy will drilldown using the syschildren relationship and apply the save query that is defined on the main datasource to all nested children. <maximo-datasource id="ddLocationDS1" object-structure="mxapioperloc" saved-query="SERVICEREQUESTLOCATION" selection-mode="none" page-size="50" pre-load="true" include-counts="false"> <schema id="dmg3k"> <attribute name="location" searchable="true" id="yya3k"/> <attribute name="description" searchable="true" id="q88jn"/> <attribute name="status" id="vj5d6"/> <attribute name="locations" child-relationship="syschildren" use-saved-query="true" id="xrprg"/> </schema> </maximo-datasource>

DATASOURCE SETUP #3:In the following datasource setup, the n-level hierarchy will drilldown using the syschildren relationship and apply the save query that is defined on the main datasource to the top level datasource query. On each child drill drilldown the child-saved-query will be applied and will override the use-saved-query property if its defined. <maximo-datasource id="ddLocationDS1" object-structure="mxapioperloc" saved-query="SERVICEREQUESTROOTLOCATION" selection-mode="none" page-size="50" pre-load="true" include-counts="false"> <schema id="dmg3k"> <attribute name="location" searchable="true" id="yya3k"/> <attribute name="description" searchable="true" id="q88jn"/> <attribute name="status" id="vj5d6"/> <attribute name="locations" child-relationship="syschildren" child-saved-query="SERVICEREQUESTLOCATION" id="xrprg"/> </schema> </maximo-datasource>


DATASOURCE SETUP #4:Not all hierarchies are created equal. The LOCATION object hierarchy in MAXIMO is a little tricky. Locations exist within SYSTEMS. Therefore the datasource query may need to account for SYSTEMS, depending on the design. In order to include all locations for a specific system, we will need to define the ctx property which defines the system to be filtered on in the datasource. The ctx property when defined on the datasource definition will be applied to all queries, top level and nested children. The following example will apply the saved-query defined on the datasource to the top-level query and in addition will also query by the filter supplied by the ctx property. The children will use the child-saved-query defined as well as the ctx property filter. <maximo-datasource id="ddLocationDS1" object-structure="mxapioperloc" ctx="systemid=PRIMARY" saved-query="SERVICEREQUESTROOTLOCATION" selection-mode="none" page-size="50" pre-load="true" include-counts="false"> <schema id="dmg3k"> <attribute name="location" searchable="true" id="yya3k"/> <attribute name="description" searchable="true" id="q88jn"/> <attribute name="status" id="vj5d6"/> <attribute name="locations" child-relationship="syschildren" child-saved-query="SERVICEREQUESTLOCATION" id="xrprg"/> </schema> </maximo-datasource>

DATALIST SETUP:
<data-list datasource="ddLocationDS1" width="100" show-search="false" tree-name="Location Tree" title="Locations" hierarchy-drill-in="true" id="bk_5r"> <!--The list item below defines the child level, which will display for all nested children--> <list-item child-attribute="locations" id="pj32_"> <container display="flex" id="z2nn_"> <label label="{item.location}" id="em6yw"/> </container> </list-item> <!--The list item below defines the top level--> <list-item id="b8v7g"> Child-Data Filtering The maximo-child-filter component can be used within a maximo-datasource to filter one or more child data sets. Maximo-Child-Filter - Properties A related child set can be sorted, filtered, and/or limited by using the following properties.

Related child sets are usually defined with the rel. prefix within the schema definition of the maximo-datasource. These record sets can be filtered using the maximo-child-filter mentioned here. A schema can have multiple related child sets defined and each one can be filtered the same way mentioned. The maximo-child-filter can also be used within nested maximo-datasource elements which can also be used to return a set.The following example illustrates how this would be implement to filter the related child set (WOACTIVITY) of a the parent work order record. The example criteria for the related child set defined (rel.woactivtiy) is that it should only contain (3) records, only display records that have a status of WAPPR and order the records in descending order by wonum. <maximo-datasource id="p2wo" object-structure="mxapiwodetail" where="location=&quot;SHIPPING&quot;" pre-load="false" page-size="10" order-by="wonum ascending" controller="WODetailController"> <schema id="myy27"> <attribute name="workorderid" unique-id="true" id="zm6zbb2"/> <attribute name="wonum" id="a_92a" title="Custom Work Order Number" max-length="35" searchable="true"/> <attribute name="rel.woactivtiy{wonum,description,status}" id="nbmw5"> <maximo-child-filter related-path="workorder.woactivity" limit="3" order-by="-wonum" where="status=&quot;WAPPR&quot;" id="wk27j"/> </attribute> <attribute name="supervisor" id="mype9"/> <attribute name="siteid" id="y6gr9" searchable="true"/> The following example show how the `maximo-child-filter` can be defined on a top level and a nested datasource. <maximo-datasource id="woDS" where="wonum > '1000'" object-structure="mxapiwodetail" order-by="wonum ascending"> <schema id="e8e8p"> <attribute name="wonum" title="Custom Work Order Number" max-length="35" searchable="true" id="kew9_"/> <attribute name="description" id="z8mkk"/> <attribute name="rel.woworklog{logtype,createby,description,class,createdate}" id="nbmw5"> <maximo-child-filter related-path="workorder.woworklog" limit="3" order-by="-createdate" where="logtype=&quot;CLIENTNOTE&quot;" id="wk27j"/> </attribute> <attribute name="status" id="d2qr8"/> <attribute name="estlabcost" scale="4" id="zjzqd"/>

The maximo-child-filter is not allowed to be used within nested child attributes. <attribute name="asset" id="gm78_"> <attribute name="location" id="vw72e">    <-- The maximo-child-filter is not allowed to exist on the next line. It can only exist within top-level attributes. <maximo-child-filter key="workorder.woworklog" limit="3" order-by="-createdate" where="logtype=&quot;CLIENTNOTE&quot;" id=""/> </attribute> </attribute>

Graphite applications for Maximo can be translated in 2 different ways. You can use .json files or you can use the Maximo xml xliff format, but, the xliff format for graphite is going to be removed as of MAS 8.7 (Graphite 2.8). How these .json files are generated is covered in the Localization section. Determining your Language and Locale The prcoess of determining which language will be used is as follows

A Maximo application is an application created with <maximo-application> A standard application is an application created with <application EAM Server is a Maximo standalone (NON MAS) server (ie, 7.6.x Maximo installs) MAS Server is a MAS installation Other Server is any other kind of server that serves up a Graphite application, such as NodeJS, etc. A browser platform is an application that targets just a browser. A mobile platform is an application that targets both a browser and a mobile container. The package.json has graphite: {platform: 'maximoMobile'} Mobile container refers to an application that is running inside the Maximo Mobile container downloaded from an App Store on a mobile device. json labels refer to labels that are created using the maxdev-cli localize command passing the --format json arg. These labels are generally deployed with the application. xliff labels refer to labels that are created using the maxdev-cli localize command passing the --format xml arg. These labels are usually not packaged with the application, but are later loaded into Maximo’s MAXLABELS table during the updatedb process. Maximo UserInfo locale refers to getting the locale from the Maximo user profile. MAS Profile locale refers to getting the locale from the MAS user profile configuration. browser locale refers to getting the locale from the browser (navigator.language or navigator.userLanguage) (i) indicates a likely invalid configuration but is provided for completeness. The following is a list of invalid configurations, that hopefully you never encounter. In cases where a browser Maximo login provides a choice to select your language, that language can only take effect if the logged in user does not have a default language set in their profile. If the browser url contains `lang=aa_BB` where `aa` is language code and `BB` is a country code, then that will become of the locale used for translation and formatting.